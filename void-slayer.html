<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <link rel="icon" type="image/png" href="https://i.imgur.com/2w3qzgz.png">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <meta http-equiv="Content-Security-Policy" content="default-src 'self'; script-src 'self' 'unsafe-inline'; style-src 'self' 'unsafe-inline'; connect-src https://script.google.com https://script.googleusercontent.com; img-src 'self' data: https://i.imgur.com; media-src 'self' https://opengameart.org; form-action 'none'; base-uri 'none'; object-src 'none';">
    <title>VOID-SLAYER | Cloud MMORPG</title>
    <style>
        :root { --bg: #050508; --panel: #111116; --accent: #8b0000; --gold: #d4af37; --text: #aaa; --admin: #ff00ff; }
        * { box-sizing: border-box; }
        body { background: var(--bg); color: var(--text); font-family: 'Crimson Text', serif; margin: 0; display: flex; height: 100vh; height: 100dvh; overflow: hidden; }
        nav { width: 220px; min-width: 220px; background: var(--panel); border-right: 1px solid #222; display: flex; flex-direction: column; padding: 20px; overflow-y: auto; }
        .nav-link { color: #666; padding: 12px 10px; border-bottom: 1px solid #1a1a1a; cursor: pointer; transition: 0.2s; font-size: 0.95rem; }
        .nav-link:hover { color: #fff; background: #1a1a1f; padding-left: 15px; }
        main { flex: 1; display: flex; flex-direction: column; min-width: 0; min-height: 0; overflow: hidden; }
        #stats-bar { background: #000; padding: 10px 20px; border-bottom: 1px solid #222; display: flex; gap: 20px; font-family: monospace; font-size: 0.85rem; align-items: center; flex-wrap: wrap; }
        .stat-val { color: var(--gold); font-weight: bold; }
        .content { flex: 1; padding: 20px; overflow-y: auto; -webkit-overflow-scrolling: touch; background: radial-gradient(circle at top, #16161d 0%, #050508 100%); }
        .card { background: rgba(20, 20, 25, 0.98); border: 1px solid #333; padding: 20px; margin-bottom: 15px; }
        .action-btn { background: #222; border: 1px solid #444; color: #ccc; padding: 10px 20px; cursor: pointer; text-transform: uppercase; margin: 4px; font-family: inherit; font-size: 0.85rem; }
        .action-btn:hover { background: var(--accent); color: white; border-color: red; }
        #game-log { height: 160px; overflow-y: auto; border-top: 1px solid #222; padding-top: 10px; font-size: 0.85rem; color: #888; margin-top: 20px; }
        #auth-screen { position: fixed; inset: 0; background: #000; z-index: 1000; display: flex; align-items: center; justify-content: center; flex-direction: column; padding: 20px; overflow-y: auto; }
        input, select { background: #111; border: 1px solid #333; color: white; padding: 12px; margin-bottom: 12px; width: 260px; box-sizing: border-box; }
        .hidden { display: none !important; }
        .debug { font-size: 0.75rem; color: #555; margin-top: 10px; font-family: monospace; }

        /* Auth form styles */
        .auth-card { background: rgba(20, 20, 25, 0.98); border: 1px solid #333; padding: 30px 40px; display: flex; flex-direction: column; align-items: center; max-width: 400px; width: 100%; }
        .auth-tabs { display: flex; gap: 0; margin-bottom: 20px; width: 100%; }
        .auth-tab { flex: 1; padding: 12px; text-align: center; cursor: pointer; background: #111; border: 1px solid #333; color: #666; text-transform: uppercase; font-family: inherit; letter-spacing: 2px; font-size: 0.85rem; transition: 0.2s; }
        .auth-tab.active { background: var(--accent); color: white; border-color: var(--accent); }
        .auth-tab:hover:not(.active) { color: #fff; background: #1a1a1f; }
        .auth-error { color: #ff4444; font-size: 0.85rem; margin-bottom: 10px; min-height: 1.2em; text-align: center; }
        .auth-success { color: #44ff44; font-size: 0.85rem; margin-bottom: 10px; min-height: 1.2em; text-align: center; }
        .auth-field { width: 100%; }
        .auth-field label { display: block; color: #888; font-size: 0.8rem; margin-bottom: 4px; text-transform: uppercase; letter-spacing: 1px; }
        .auth-field input, .auth-field select { width: 100%; }
        .auth-divider { width: 100%; border-top: 1px solid #222; margin: 15px 0; position: relative; }
        .auth-divider span { position: absolute; top: -10px; left: 50%; transform: translateX(-50%); background: rgba(20, 20, 25, 0.98); padding: 0 10px; color: #555; font-size: 0.8rem; }
        .realm-info { font-size: 0.75rem; color: #555; text-align: center; margin-top: -5px; margin-bottom: 10px; }
        .name-link { color: inherit; cursor: pointer; text-decoration: none; border-bottom: 1px dotted #555; transition: 0.15s; }
        .name-link:hover { color: var(--gold); border-bottom-color: var(--gold); }

        /* Result toast notifications */
        .result-toast { position: fixed; top: 50%; left: 50%; transform: translate(-50%, -50%); z-index: 9999; padding: 25px 40px; border: 2px solid; text-align: center; font-size: 1.1rem; animation: toastIn 0.3s ease, toastOut 0.4s ease 2.6s; pointer-events: none; min-width: 300px; max-width: 90vw; }
        .result-toast.victory { background: rgba(0, 40, 0, 0.95); border-color: #44ff44; color: #44ff44; }
        .result-toast.defeat { background: rgba(50, 0, 0, 0.95); border-color: #ff4444; color: #ff4444; }
        .result-toast.purchase { background: rgba(40, 30, 0, 0.95); border-color: var(--gold); color: var(--gold); }
        .result-toast.error { background: rgba(50, 0, 0, 0.95); border-color: #ff4444; color: #ff4444; }
        .result-toast .toast-title { font-size: 1.4rem; font-weight: bold; margin-bottom: 8px; letter-spacing: 2px; text-transform: uppercase; }
        .result-toast .toast-detail { font-size: 0.9rem; color: #ccc; margin-top: 5px; }
        @keyframes toastIn { from { opacity: 0; transform: translate(-50%, -50%) scale(0.8); } to { opacity: 1; transform: translate(-50%, -50%) scale(1); } }
        @keyframes toastOut { from { opacity: 1; } to { opacity: 0; } }
        @keyframes syncPulse { 0%, 100% { opacity: 1; } 50% { opacity: 0.4; } }
        #sync-dot.syncing { animation: syncPulse 1s ease-in-out infinite; }

        /* Player profile page */
        .profile-page-header { display: flex; align-items: center; gap: 20px; margin-bottom: 20px; }
        .profile-page-avatar { font-size: 3rem; width: 80px; height: 80px; display: flex; align-items: center; justify-content: center; border: 2px solid #333; background: #0a0a0a; }
        .profile-page-stats { display: grid; grid-template-columns: repeat(auto-fill, minmax(140px, 1fr)); gap: 10px; margin: 20px 0; }
        .profile-stat-card { background: #0a0a0a; border: 1px solid #222; padding: 12px; text-align: center; }
        .profile-stat-card .stat-label { font-size: 0.75rem; color: #666; text-transform: uppercase; letter-spacing: 1px; }
        .profile-stat-card .stat-value { font-size: 1.3rem; color: var(--gold); font-weight: bold; margin-top: 4px; }

        /* Avatar selector */
        .avatar-option { width: 50px; height: 50px; display: flex; align-items: center; justify-content: center; font-size: 1.8rem; border: 2px solid #333; cursor: pointer; transition: 0.2s; background: #111; }
        .avatar-option:hover { border-color: var(--gold); background: #1a1a1f; transform: scale(1.1); }
        .avatar-option.selected { border-color: var(--accent); background: rgba(139, 0, 0, 0.2); box-shadow: 0 0 10px rgba(139, 0, 0, 0.5); }

        /* Mobile hamburger */
        #mobile-header { display: none; background: var(--panel); padding: 10px 15px; border-bottom: 1px solid #222; align-items: center; justify-content: space-between; z-index: 50; }
        #menu-toggle { background: none; border: 1px solid #444; color: #ccc; font-size: 1.3rem; padding: 6px 12px; cursor: pointer; font-family: inherit; }
        #nav-overlay { display: none; position: fixed; inset: 0; background: rgba(0,0,0,0.6); z-index: 98; }

        /* Mobile responsive */
        @media (max-width: 768px) {
            body { flex-direction: column; }
            #mobile-header { display: flex; }
            nav { position: fixed; top: 0; left: -280px; width: 260px; min-width: 260px; height: 100%; z-index: 99; transition: left 0.3s ease; padding-top: 15px; }
            nav.open { left: 0; }
            #nav-overlay.open { display: block; }
            main { flex: 1; min-height: 0; overflow: hidden; }
            #stats-bar { padding: 8px 12px; gap: 10px; font-size: 0.75rem; }
            #sync-label { display: none; }
            #sync-dot { width: 6px; height: 6px; }
            .content { padding: 12px; padding-bottom: 80px; }
            .card { padding: 15px; }
            .action-btn { padding: 10px 16px; font-size: 0.8rem; }
            #auth-screen { padding: 15px; }
            .auth-card { padding: 20px 15px; }
            input, select { width: 100%; }
            #chat-in { width: 65% !important; }
        }
        /* Boss System */
        .boss-card { border: 1px solid #333; padding: 15px; margin-bottom: 12px; background: #0a0a0a; position: relative; overflow: hidden; }
        .boss-card.locked { opacity: 0.4; pointer-events: none; }
        .boss-card .boss-tier { position: absolute; top: 0; right: 0; padding: 4px 10px; font-size: 0.7rem; text-transform: uppercase; letter-spacing: 1px; }
        .boss-hp-bar { background: #222; height: 22px; border: 1px solid #444; position: relative; overflow: hidden; margin: 10px 0; }
        .boss-hp-fill { height: 100%; transition: width 0.3s; }
        .boss-hp-text { position: absolute; top: 0; left: 0; right: 0; bottom: 0; display: flex; align-items: center; justify-content: center; font-size: 0.8rem; font-family: monospace; color: #fff; text-shadow: 0 0 4px #000; }
        .boss-reward-tag { display: inline-block; padding: 2px 8px; font-size: 0.7rem; text-transform: uppercase; letter-spacing: 1px; margin-right: 5px; }
        .boss-reward-tag.xp { background: rgba(68,170,255,0.15); color: #4af; border: 1px solid #4af; }
        .boss-reward-tag.gold { background: rgba(212,175,55,0.15); color: var(--gold); border: 1px solid var(--gold); }
        .boss-reward-tag.item { background: rgba(170,68,255,0.15); color: #a4f; border: 1px solid #a4f; }

        /* Trophy Rarity Colors */
        .rarity-common { color: #aaa; border-color: #aaa; }
        .rarity-uncommon { color: #44ff44; border-color: #44ff44; }
        .rarity-rare { color: #4488ff; border-color: #4488ff; }
        .rarity-epic { color: #aa44ff; border-color: #aa44ff; }
        .rarity-legendary { color: #ff8800; border-color: #ff8800; }

        .trophy-item { display: inline-flex; align-items: center; gap: 6px; padding: 6px 12px; margin: 4px; border: 1px solid; background: rgba(20,20,25,0.9); font-size: 0.85rem; }
        .trophy-grid { display: flex; flex-wrap: wrap; gap: 6px; margin: 10px 0; }

        .trophy-popup { position: fixed; top: 50%; left: 50%; transform: translate(-50%, -50%); z-index: 9998; background: rgba(10,10,15,0.98); border: 2px solid #444; padding: 25px 35px; text-align: center; min-width: 250px; max-width: 90vw; animation: toastIn 0.2s ease; box-shadow: 0 0 40px rgba(0,0,0,0.8); }

        /* Locked avatar styling */
        .avatar-option.avatar-locked { opacity: 0.35; cursor: not-allowed; position: relative; }
        .avatar-option.avatar-locked:hover { border-color: #555; background: #111; transform: none; }
        .avatar-option .avatar-lock-tooltip { display: none; position: absolute; bottom: -22px; left: 50%; transform: translateX(-50%); font-size: 0.6rem; color: #ff6666; white-space: nowrap; background: #0a0a0a; padding: 2px 6px; border: 1px solid #333; z-index: 5; }
        .avatar-option.avatar-locked:hover .avatar-lock-tooltip { display: block; }

        /* Daily Quest styling */
        .quest-card { background: #0a0a0a; border: 1px solid #333; padding: 12px 15px; margin-bottom: 8px; display: flex; justify-content: space-between; align-items: center; flex-wrap: wrap; gap: 8px; }
        .quest-card.quest-complete { border-color: #44ff44; background: rgba(0,40,0,0.3); }
        .quest-progress-bar { background: #222; height: 8px; border: 1px solid #444; flex: 1; min-width: 80px; max-width: 200px; position: relative; overflow: hidden; }
        .quest-progress-fill { height: 100%; background: linear-gradient(90deg, var(--accent), #ff8800); transition: width 0.3s; }

        /* Void Entity glow */
        .boss-card.void-entity-card { border-color: #ff8800; box-shadow: 0 0 15px rgba(255,136,0,0.15); }

        /* Audio toggle switch */
        .audio-toggle-wrap { display: flex; align-items: center; justify-content: center; gap: 10px; padding: 12px 0; border-top: 1px solid #1a1a1a; margin-top: 10px; }
        .audio-toggle-label { font-size: 0.8rem; color: #666; text-transform: uppercase; letter-spacing: 1px; user-select: none; }
        .audio-toggle-label.active { color: var(--gold); }
        .toggle-switch { position: relative; width: 42px; height: 22px; cursor: pointer; flex-shrink: 0; }
        .toggle-switch input { opacity: 0; width: 0; height: 0; position: absolute; }
        .toggle-track { position: absolute; inset: 0; background: #222; border: 1px solid #444; border-radius: 11px; transition: 0.25s; }
        .toggle-knob { position: absolute; top: 3px; left: 3px; width: 16px; height: 16px; background: #666; border-radius: 50%; transition: 0.25s; }
        .toggle-switch input:checked ~ .toggle-track { background: var(--accent); border-color: #cc0000; }
        .toggle-switch input:checked ~ .toggle-knob { left: 23px; background: var(--gold); }

    </style>
</head>
<body>

<div id="auth-screen">
    <img src="https://i.imgur.com/2w3qzgz.png" alt="VOID-SLAYER" style="max-width: min(320px, 70vw); max-height: 18vh; width: auto; height: auto; object-fit: contain; margin-bottom: 6px;">
    <div style="letter-spacing: 0.55em; font-size: 0.78rem; font-family: 'Crimson Text', serif; text-transform: uppercase; color: #b0b0b8; background: linear-gradient(90deg, #666 0%, #ccc 40%, #fff 50%, #ccc 60%, #666 100%); -webkit-background-clip: text; -webkit-text-fill-color: transparent; background-clip: text; text-shadow: none; filter: drop-shadow(0 0 6px rgba(139,0,0,0.55)); margin-bottom: 18px; padding-left: 0.55em;">‚Äî &nbsp;A L I V E &nbsp;‚Äî</div>

    <div class="auth-card">
        <div class="auth-tabs">
            <div class="auth-tab active" id="tab-login-btn" onclick="switchAuthTab('login')">Login</div>
            <div class="auth-tab" id="tab-register-btn" onclick="switchAuthTab('register')">Register</div>
        </div>

        <div id="auth-error" class="auth-error"></div>
        <div id="auth-success" class="auth-success"></div>

        <!-- Login Form -->
        <div id="auth-login">
            <div class="auth-field">
                <label>Username</label>
                <input type="text" id="login-username" placeholder="Enter username" onkeypress="if(event.key==='Enter')doLogin()">
            </div>
            <div class="auth-field">
                <label>Password</label>
                <input type="password" id="login-password" placeholder="Enter password" onkeypress="if(event.key==='Enter')doLogin()">
            </div>
            <button class="action-btn" style="width:100%; margin: 10px 0 0 0;" onclick="doLogin()">Enter the Void</button>
        </div>

        <!-- Register Form -->
        <div id="auth-register" class="hidden">
            <div class="auth-field">
                <label>Username</label>
                <input type="text" id="reg-username" placeholder="Choose a username" onkeypress="if(event.key==='Enter')doRegister()">
            </div>
            <div class="auth-field">
                <label>Password</label>
                <input type="password" id="reg-password" placeholder="Choose a password" onkeypress="if(event.key==='Enter')doRegister()">
            </div>
            <div class="auth-field">
                <label>Confirm Password</label>
                <input type="password" id="reg-password2" placeholder="Confirm password" onkeypress="if(event.key==='Enter')doRegister()">
            </div>
            <div class="auth-field">
                <label>Race</label>
                <select id="race-sel" style="width:100%;">
                    <option value="Hollow">Hollow (+Str)</option>
                    <option value="Wraith">Wraith (+Wis)</option>
                </select>
            </div>
            <button class="action-btn" style="width:100%; margin: 10px 0 0 0;" onclick="doRegister()">Create Character</button>
        </div>

        <div class="auth-divider"><span>VOID-SLAYER</span></div>
        <input type="hidden" id="realm-name" value="void-realm-default">

        <div class="debug" id="connection-status">Initializing...</div>
        <div class="debug" id="auth-debug" style="margin-top: 8px; max-height: 80px; overflow-y: auto;"></div>
        <div style="margin-top: 10px;">
            <span class="debug" style="cursor:pointer; color:#664444; border-bottom:1px dotted #664444;" onclick="if(confirm('Clear all local data? You will need to register again.')){localStorage.removeItem('void-accounts-void-realm-default');localStorage.removeItem('void-gamestate-void-realm-default');document.getElementById('auth-debug').textContent='Local data cleared.';document.getElementById('auth-error').textContent='';}">Clear local data</span>
        </div>
    </div>
</div>

<div id="nav-overlay" onclick="closeMenu()"></div>

<nav id="main-nav">
    <h2 style="color:var(--accent)">VOID SLAYER</h2>
    <div class="nav-link" onclick="goTab('grind')">The Frontier</div>
    <div class="nav-link" onclick="goTab('bosses'); refreshBossUI();">Bosses</div>
    <div class="nav-link" onclick="goTab('quests'); refreshQuestsUI();">Daily Quests</div>
    <div class="nav-link" onclick="goTab('pvp'); refreshPvpTargets();">The Arena</div>
    <div class="nav-link" onclick="goTab('guild'); refreshGuildUI();">Guild Hall</div>
    <div class="nav-link" onclick="goTab('wars'); refreshWarsUI();">Guild Wars</div>
    <div class="nav-link" onclick="goTab('chat'); displayChat();">Tavern</div>
    <div class="nav-link" onclick="goTab('shop'); refreshShop();">Black Market</div>
    <div class="nav-link" onclick="goTab('lead'); loadLeaderboard();">Leaderboard</div>
    <div class="nav-link" onclick="goTab('news'); refreshNews();">News</div>
    <div class="nav-link" onclick="goTab('profile')">Profile</div>
    <div id="nav-admin" class="nav-link hidden" onclick="goTab('admin'); refreshAdminConsole();" style="color:var(--admin);">üîí Admin Console</div>
    <div class="debug" style="margin-top: auto; padding-top: 20px;">
        <span id="player-count">0</span> players online<br>
        <span id="cloud-status" style="color: #ffaa00;">Cloud: Connecting...</span>
    </div>
    <div class="audio-toggle-wrap">
        <span class="audio-toggle-label" id="audio-label">Sound</span>
        <label class="toggle-switch">
            <input type="checkbox" id="audio-toggle" onchange="toggleAudio()">
            <span class="toggle-track"></span>
            <span class="toggle-knob"></span>
        </label>
    </div>
</nav>

<div id="mobile-header">
    <button id="menu-toggle" onclick="toggleMenu()">‚ò∞</button>
    <span style="color:var(--accent); font-weight:bold; letter-spacing:2px;">VOID-SLAYER</span>
</div>

<main>
    <div id="stats-bar">
        <span>Lv <span class="stat-val" id="stat-level">1</span></span>
        <span>XP <span class="stat-val" id="stat-xp">0</span>/<span id="stat-xp-next">100</span></span>
        <span>HP <span class="stat-val" id="stat-hp">100</span>/<span id="stat-maxhp">100</span></span>
        <span>STR <span class="stat-val" id="stat-str">10</span></span>
        <span title="Global XP Multiplier">WIS <span class="stat-val" id="stat-wis">10</span> <span id="stat-wis-mult" style="color:#888; font-size:0.75rem;"></span></span>
        <span style="color:var(--gold)">‚öú <span class="stat-val" id="stat-gold">0</span></span>
        <span id="stat-guild"></span>
        <span style="margin-left:auto; display:flex; align-items:center; gap:10px;">
            <span id="sync-indicator" title="Cloud: Connecting..." style="display:flex; align-items:center; gap:4px; font-size:0.75rem; color:#ffaa00; cursor:default; user-select:none;">
                <span id="sync-dot" class="syncing" style="width:7px; height:7px; border-radius:50%; background:#ffaa00; display:inline-block; transition: background 0.3s, box-shadow 0.3s;"></span>
                <span id="sync-label">Connecting...</span>
            </span>
            <span style="cursor:pointer; color:#888; border-bottom:1px dotted #555; transition:0.15s;" onclick="goTab('profile')" onmouseover="this.style.color='var(--gold)';this.style.borderBottomColor='var(--gold)'" onmouseout="this.style.color='#888';this.style.borderBottomColor='#555'">‚öô Profile</span>
        </span>
    </div>

    <div id="desync-banner" class="hidden" style="background:rgba(139,60,0,0.9); border-bottom:1px solid #ff8844; padding:8px 20px; display:flex; align-items:center; justify-content:space-between; gap:12px; flex-wrap:wrap; font-size:0.85rem;">
        <span style="color:#ffcc88;">‚ö† <strong>Cloud sync issue</strong> ‚Äî Your progress is saved locally, but having trouble reaching the server. <span id="desync-fail-count"></span></span>
        <span style="display:flex; gap:8px; align-items:center;">
            <span id="desync-status" style="color:#ff8844; font-size:0.8rem;">Retrying...</span>
            <button class="action-btn" onclick="location.reload()" style="padding:6px 14px; font-size:0.8rem; background:#553300; border-color:#ff8844; color:#ffcc88;">‚Üª Refresh Page</button>
            <button class="action-btn" onclick="dismissDesyncBanner()" style="padding:6px 10px; font-size:0.8rem; background:transparent; border-color:#885500; color:#aa7733;">‚úï</button>
        </span>
    </div>

    <div class="content">
        <!-- FRONTIER TAB -->
        <div id="tab-grind">
            <div class="card">
                <h2>The Frontier</h2>
                <p>The dark frontier sprawls before you, teeming with shadowy foes. Your blade thirsts for blood.</p>
                <div style="margin: 10px 0;"><img src="https://i.imgur.com/g2nk15h.png" alt="Void Wraith" style="max-width: 120px; max-height: 120px; width: auto; height: auto; image-rendering: pixelated;"></div>
                <button class="action-btn" onclick="doGrind()">Slay Minions</button>
                <button class="action-btn" onclick="doRest()" style="background:#1a3a1a; border-color:#2a5a2a;">üõå Rest (Restore 50% HP)</button>
            </div>
            <div id="game-log"></div>
        </div>

        <!-- LEADERBOARD TAB -->
        <div id="tab-lead" class="hidden">
            <div class="card">
                <h2>Leaderboard</h2>
                <input type="text" id="lead-search" placeholder="Search players..." style="width:100%; max-width:300px; margin-bottom:15px;" oninput="loadLeaderboard()">
                <div id="leaderboard-list" style="font-family:monospace; font-size:0.9rem;"></div>
            </div>
        </div>

        <!-- SHOP TAB -->
        <div id="tab-shop" class="hidden">
            <div class="card">
                <h2>Black Market</h2>
                <p>A hooded merchant whispers prices. Gold buys power. <span style="color:var(--gold); font-weight:bold;">Your gold: <span id="shop-gold">0</span></span></p>
                <div id="shop-items"></div>
            </div>
        </div>

        <!-- PVP TAB -->
        <div id="tab-pvp" class="hidden">
            <div class="card">
                <h2>The Arena</h2>
                <p>Challenge other slayers to mortal combat. <span style="color:#ff4444;">Winner takes ALL of the loser's gold.</span></p>
                <div id="pvp-targets"></div>
            </div>
        </div>

        <!-- GUILD TAB -->
        <div id="tab-guild" class="hidden">
            <div class="card">
                <h2>Guild Hall</h2>
                <div id="guild-content"></div>
            </div>
        </div>

        <!-- WARS TAB -->
        <div id="tab-wars" class="hidden">
            <div class="card">
                <h2>‚öîÔ∏è Guild Wars</h2>
                <p style="color:#888;">Guilds battle for supremacy. First to 20,000 frontier kills wins!</p>
                
                <div id="active-wars-section" style="margin-top:20px;">
                    <h3 style="color:var(--accent);">Active Wars</h3>
                    <div id="active-wars-list"></div>
                </div>
                
                <div id="war-history-section" style="margin-top:30px;">
                    <h3 style="color:#888;">War History</h3>
                    <div id="war-history-list"></div>
                </div>
            </div>
        </div>

        <!-- BOSSES TAB -->
        <div id="tab-bosses" class="hidden">
            <div class="card">
                <h2>üî• Boss Arena</h2>
                <p style="color:#888;">Ancient terrors await. New bosses unlock every 10 levels. Defeat them for legendary trophies and massive rewards.</p>
                <div id="boss-rest-area" style="margin-bottom:15px;">
                    <button class="action-btn" onclick="doBossRest()" style="background:#1a3a1a; border-color:#2a5a2a;">üõå Rest (Restore 50% HP)</button>
                    <span id="boss-hp-display" style="color:#888; font-size:0.85rem; margin-left:10px;"></span>
                </div>
                <div id="boss-list"></div>
                <div id="boss-fight-area" class="hidden" style="margin-top:20px;"></div>
            </div>
        </div>

        <!-- DAILY QUESTS TAB -->
        <div id="tab-quests" class="hidden">
            <div class="card">
                <h2>üìú Daily Void Quests</h2>
                <p style="color:#888;">Complete quests for bonus rewards. Quests reset every 24 hours.</p>
                <div id="quest-timer" style="color:#666; font-size:0.85rem; margin-bottom:15px;"></div>
                <div id="quest-list"></div>
            </div>
        </div>

        <!-- CHAT TAB -->
        <div id="tab-chat" class="hidden">
            <div class="card">
                <h2>The Tavern</h2>
                <div id="chat-log" style="height:300px; overflow-y:auto; border:1px solid #333; padding:10px; margin-bottom:10px; font-size:0.9rem;"></div>
                <div style="display:flex; gap:5px;">
                    <input type="text" id="chat-in" placeholder="Speak..." style="flex:1; width:auto;" onkeypress="if(event.key==='Enter')sendChatMsg()">
                    <button class="action-btn" onclick="sendChatMsg()">Send</button>
                </div>
            </div>
        </div>

        <!-- PROFILE TAB -->
        <div id="tab-profile" class="hidden">
            <div class="card">
                <h2>Profile Settings</h2>
                <p style="color:#888;">Customize your character profile.</p>
                
                <div style="margin:20px 0;">
                    <label style="display:block; color:#888; font-size:0.85rem; margin-bottom:5px;">Display Name</label>
                    <input type="text" id="profile-displayname" placeholder="Your display name" style="width:300px; max-width:100%;">
                    <p style="color:#666; font-size:0.8rem; margin-top:5px;">This is how other players will see you.</p>
                </div>
                
                <div style="margin:20px 0;">
                    <label style="display:block; color:#888; font-size:0.85rem; margin-bottom:8px;">Avatar</label>
                    <div id="avatar-selector" style="display:flex; gap:10px; flex-wrap:wrap;"></div>
                    <input type="hidden" id="profile-avatar" value="‚öîÔ∏è">
                </div>
                
                <div style="margin:20px 0;">
                    <label style="display:block; color:#888; font-size:0.85rem; margin-bottom:5px;">Bio</label>
                    <textarea id="profile-bio" placeholder="Tell others about yourself..." style="width:100%; max-width:500px; height:80px; background:#111; border:1px solid #333; color:white; padding:10px; font-family:inherit; resize:vertical;"></textarea>
                    <p style="color:#666; font-size:0.8rem; margin-top:5px;">Maximum 200 characters.</p>
                </div>
                
                <button class="action-btn" onclick="saveProfile()">Save Changes</button>
                
                <div id="profile-status" style="margin-top:15px; font-size:0.9rem; color:#888;"></div>
                
                <div style="margin-top:30px; border-top:1px solid #222; padding-top:20px;">
                    <h3 style="color:var(--gold);">üèÜ Trophy Collection</h3>
                    <div id="profile-trophies"></div>
                </div>
            </div>
        </div>

        <!-- PLAYER VIEW TAB (when clicking a player name) -->
        <div id="tab-playerview" class="hidden">
            <div class="card">
                <button class="action-btn" onclick="window._goBack()" style="margin-bottom:15px; font-size:0.8rem;">‚Üê Back</button>
                <div id="playerview-content"></div>
            </div>
        </div>

        <!-- NEWS TAB -->
        <div id="tab-news" class="hidden">
            <div class="card">
                <h2>Realm News</h2>
                
                <div id="admin-news-post" class="hidden" style="margin-bottom:20px; padding:15px; background:#0a0a0a; border:1px solid #444;">
                    <h3 style="color:var(--admin); margin-top:0;">‚úç Post News (Admin)</h3>
                    <textarea id="news-input" placeholder="Type your news announcement..." style="width:100%; height:80px; background:#111; border:1px solid #333; color:white; padding:10px; font-family:inherit; resize:vertical;"></textarea>
                    <button class="action-btn" onclick="postNews()" style="margin-top:10px; background:var(--admin); border-color:var(--admin);">üì¢ Post News</button>
                </div>
                
                <div id="news-list"></div>
            </div>
        </div>

        <!-- ADMIN CONSOLE TAB (Admin Only) -->
        <div id="tab-admin" class="hidden">
            <div class="card">
                <h2 style="color:var(--admin)">üîí Admin Console</h2>
                <div id="admin-info" style="margin:15px 0; padding:15px; background:#0a0a0a; border:1px solid #222; font-family:monospace; font-size:0.85rem;"></div>
                
                <div style="margin-top:20px;">
                    <h3 style="color:var(--admin); margin-bottom:10px;">Player Management</h3>
                    <input type="text" id="admin-player-search" placeholder="Search players..." style="width:100%; max-width:300px; margin-bottom:10px;" oninput="refreshAdminPlayerList()">
                    <div id="admin-player-list" style="max-height:300px; overflow-y:auto;"></div>
                </div>
                
                <div style="margin-top:30px; border-top:1px solid #222; padding-top:20px;">
                    <h3 style="color:var(--admin); margin-bottom:10px;">Server Actions</h3>
                    <div style="display:flex; flex-wrap:wrap; gap:8px;">
                        <button class="action-btn" onclick="adminResetStats()" style="background:#3a0000; border-color:#660000;">üîÑ Reset All Stats</button>
                        <button class="action-btn" onclick="adminFullReset()" style="background:#3a0000; border-color:#660000;">üí£ Full Server Reset</button>
                        <button class="action-btn" onclick="adminClearChat()" style="background:#222;">üßπ Clear All Chat</button>
                        <button class="action-btn" onclick="adminClearNews()" style="background:#222;">üì∞ Clear All News</button>
                        <button class="action-btn" onclick="adminClearWars()" style="background:#222;">‚öî Clear War History</button>
                        <button class="action-btn" onclick="adminGiveGold()" style="background:#2a2a00; border-color:#444400;">üí∞ Give Gold</button>
                    </div>
                    <div id="admin-action-status" style="margin-top:10px; font-size:0.85rem; color:#888;"></div>
                </div>
                
                <div style="margin-top:30px; border-top:1px solid #222; padding-top:20px;">
                    <h3 style="color:var(--admin); margin-bottom:10px;">Backup</h3>
                    <div style="display:flex; flex-wrap:wrap; gap:8px;">
                        <button class="action-btn" onclick="downloadBackup()" style="background:var(--admin); border-color:var(--admin);">‚¨á Download Backup</button>
                        <label class="action-btn" style="display:inline-block; cursor:pointer;">
                            ‚¨Ü Upload Backup
                            <input type="file" accept=".json" onchange="uploadBackup(event)" style="display:none;">
                        </label>
                    </div>
                    <div id="backup-status" style="margin-top:10px; font-size:0.85rem; color:#888;"></div>
                </div>
            </div>
        </div>
    </div>
</main>

<script>
    "use strict";
    // ============================================
    // SECURITY: IIFE ENCAPSULATION
    // ============================================
    (function() {

    // ============================================
    // AUDIO SYSTEM
    // ============================================
    var BGM_URL = 'https://opengameart.org/sites/default/files/Dark%20Clouds%20Covering%20The%20Horizon%20-%20Loading%20Background%20Music.wav';
    var ATTACK_SFX_URL = 'https://opengameart.org/sites/default/files/best_snare_0.wav';

    // --- State ---
    var audioEnabled = false;
    var bgmPlaying = false;
    var bgmBlessed = false;
    var sfxUnlocked = false;

    // --- BGM setup ---
    var bgmAudio = new Audio();
    bgmAudio.src = BGM_URL;
    bgmAudio.loop = true;
    bgmAudio.volume = 0.35;
    bgmAudio.preload = 'auto';

    // --- Attack SFX pool ---
    var POOL_SIZE = 5;
    var attackPool = [];
    for (var i = 0; i < POOL_SIZE; i++) {
        var a = new Audio();
        a.src = ATTACK_SFX_URL;
        a.volume = 0.5;
        a.preload = 'auto';
        attackPool.push(a);
    }
    var attackIdx = 0;

    // Load saved preference (off by default)
    try {
        audioEnabled = localStorage.getItem('void-slayer-audio') === 'on';
    } catch(e) {}

    // Set toggle checkbox to match saved state on load
    document.addEventListener('DOMContentLoaded', function() {
        var cb = document.getElementById('audio-toggle');
        var label = document.getElementById('audio-label');
        if (cb) cb.checked = audioEnabled;
        if (label && audioEnabled) label.classList.add('active');
    });

    function tryPlayBGM() {
        if (bgmPlaying || !audioEnabled) return;
        var promise = bgmAudio.play();
        if (promise) {
            promise.then(function() { bgmPlaying = true; }).catch(function() {});
        }
    }

    function stopBGM() {
        try {
            bgmAudio.pause();
            bgmAudio.currentTime = 0;
        } catch(e) {}
        bgmPlaying = false;
    }

    // Retry BGM once data is buffered
    bgmAudio.addEventListener('canplaythrough', function() {
        if (bgmBlessed && audioEnabled && !bgmPlaying) tryPlayBGM();
    });
    bgmAudio.addEventListener('canplay', function() {
        if (bgmBlessed && audioEnabled && !bgmPlaying) tryPlayBGM();
    });

    // Bless audio elements on first interaction after toggle is on
    function blessAudio() {
        if (!audioEnabled) return;

        // Bless BGM
        if (!bgmBlessed) {
            bgmBlessed = true;
            bgmAudio.load();
            tryPlayBGM();
        }

        // Bless SFX pool
        if (!sfxUnlocked) {
            sfxUnlocked = true;
            attackPool.forEach(function(el) {
                var origVol = el.volume;
                el.volume = 0;
                var p = el.play();
                if (p) {
                    p.then(function() {
                        el.pause();
                        el.currentTime = 0;
                        el.volume = origVol;
                    }).catch(function() { el.volume = origVol; });
                }
            });
        }

        // If blessed, stop listening
        if (bgmBlessed && sfxUnlocked) {
            document.removeEventListener('click', blessAudio, true);
            document.removeEventListener('touchstart', blessAudio, true);
            document.removeEventListener('touchend', blessAudio, true);
            document.removeEventListener('keydown', blessAudio, true);
        }
    }

    document.addEventListener('click', blessAudio, true);
    document.addEventListener('touchstart', blessAudio, true);
    document.addEventListener('touchend', blessAudio, true);
    document.addEventListener('keydown', blessAudio, true);

    function playAttackSound() {
        if (!audioEnabled || !sfxUnlocked) return;
        var el = attackPool[attackIdx];
        attackIdx = (attackIdx + 1) % POOL_SIZE;
        el.currentTime = 0;
        var p = el.play();
        if (p) p.catch(function() {});
    }

    // Toggle handler ‚Äî called from the checkbox onchange
    window.toggleAudio = function() {
        var cb = document.getElementById('audio-toggle');
        var label = document.getElementById('audio-label');
        audioEnabled = cb && cb.checked;

        if (label) {
            if (audioEnabled) label.classList.add('active');
            else label.classList.remove('active');
        }

        // Save to localStorage
        try { localStorage.setItem('void-slayer-audio', audioEnabled ? 'on' : 'off'); } catch(e) {}

        if (audioEnabled) {
            // If not blessed yet, the capturing listeners will handle it on next interaction
            // If already blessed, start BGM now
            if (bgmBlessed) {
                tryPlayBGM();
            } else {
                // Re-attach listeners in case they were removed
                document.addEventListener('click', blessAudio, true);
                document.addEventListener('touchstart', blessAudio, true);
                document.addEventListener('touchend', blessAudio, true);
                document.addEventListener('keydown', blessAudio, true);
                // The toggle click itself is a gesture ‚Äî bless immediately
                blessAudio();
            }
        } else {
            stopBGM();
        }
    };

    // ============================================
    // SECURITY: HTML SANITIZATION
    // ============================================
    function sanitize(str) {
        if (str === null || str === undefined) return '';
        return String(str)
            .replace(/&/g, '&amp;')
            .replace(/</g, '&lt;')
            .replace(/>/g, '&gt;')
            .replace(/"/g, '&quot;')
            .replace(/'/g, '&#x27;')
            .replace(/\//g, '&#x2F;');
    }

    // Sanitize for use inside onclick attribute strings (prevent quote-breaking injection)
    function safeAttr(str) {
        return sanitize(str).replace(/[^a-zA-Z0-9_\-]/g, '');
    }

    // Validate that a username only contains safe characters
    function isValidUsername(name) {
        return /^[a-zA-Z0-9_\-]{3,20}$/.test(name);
    }

    // ============================================
    // SECURITY: CONSOLE & DEVTOOLS PROTECTION
    // ============================================
    // Disable console methods to prevent easy stat manipulation
    (function() {
        const noop = function() {};
        // Store originals for internal error logging only
        const _origWarn = console.warn;
        const _origError = console.error;
        
        try {
            Object.defineProperty(window, 'console', {
                get: function() {
                    return {
                        log: noop, warn: _origWarn, error: _origError, 
                        info: noop, debug: noop, dir: noop, table: noop,
                        clear: noop, trace: noop, assert: noop,
                        group: noop, groupEnd: noop, groupCollapsed: noop,
                        time: noop, timeEnd: noop, profile: noop, profileEnd: noop
                    };
                },
                configurable: false
            });
        } catch(e) {}
    })();

    // ============================================
    // SECURITY: RATE LIMITING
    // ============================================
    const _cooldowns = {};
    function rateLimited(action, cooldownMs) {
        const now = Date.now();
        if (_cooldowns[action] && (now - _cooldowns[action]) < cooldownMs) {
            return true; // Still on cooldown
        }
        _cooldowns[action] = now;
        return false;
    }

    // ============================================
    // SECURITY: INPUT VALIDATION
    // ============================================
    function validateChatMessage(msg) {
        if (!msg || typeof msg !== 'string') return null;
        msg = msg.trim();
        if (msg.length === 0 || msg.length > 300) return null;
        return msg;
    }

    function validateDisplayName(name) {
        if (!name || typeof name !== 'string') return null;
        name = name.trim();
        if (name.length < 2 || name.length > 20) return null;
        // Only allow alphanumeric, spaces, hyphens, underscores
        if (!/^[a-zA-Z0-9 _\-]+$/.test(name)) return null;
        return name;
    }

    function validateBio(bio) {
        if (!bio || typeof bio !== 'string') return null;
        bio = bio.trim();
        if (bio.length > 200) return null;
        return bio;
    }

    function validateGuildName(name) {
        if (!name || typeof name !== 'string') return null;
        name = name.trim();
        if (name.length < 2 || name.length > 30) return null;
        if (!/^[a-zA-Z0-9 _\-]+$/.test(name)) return null;
        return name;
    }

    function validateGuildTag(tag) {
        if (!tag || typeof tag !== 'string') return null;
        tag = tag.trim().toUpperCase();
        if (tag.length < 3 || tag.length > 5) return null;
        if (!/^[A-Z0-9]+$/.test(tag)) return null;
        return tag;
    }

    // ============================================
    // SECURITY: PASSWORD HASHING (SHA-256)
    // ============================================
    async function hashPassword(password, salt) {
        const data = new TextEncoder().encode(salt + ':' + password);
        const hash = await crypto.subtle.digest('SHA-256', data);
        return Array.from(new Uint8Array(hash)).map(b => b.toString(16).padStart(2,'0')).join('');
    }

    const PASSWORD_SALT = 'V01D-SL4Y3R-S4LT-2024';

    // ============================================
    // CLOUD SYNC CONFIGURATION
    // ============================================
    const CLOUD_CONFIG = {
        webAppUrl: 'https://script.google.com/macros/s/AKfycbyJEZzZiIf3QyawNA-mR_lUHknsWok_2-FLp68odIYxKSiDMGT_F0JcZwJqnGDEMYI/exec',
        sheetId: '1EblrSWCeDCgOVLB3wJ9rkQ56-SdThchkcpaa3bR4Bas',
        heartbeatInterval: 60000, // 60 seconds ‚Äî cloud save interval
        autoSaveDelay: 15000, // 15 seconds after marking dirty (was 3s ‚Äî too fast for Sheets)
        cloudRefreshInterval: 20000 // 20 seconds ‚Äî pull other players' changes
    };

    let cloudSyncTimer = null;
    let cloudRefreshTimer = null;
    let isDirty = false;
    let lastSyncTime = 0;
    let autoSaveTimer = null;
    let cloudSaveInProgress = false; // Prevent overlapping save requests
    let localChatIds = new Set(); // Track chat messages WE created this session

    // ============================================
    // GAME STATE & CONSTANTS
    // ============================================
    const ADMIN = 'boyo1991';
    let currentUser = null;
    let currentTab = 'grind';
    let _lastViewTab = 'grind';
    let p = {}; // Current player
    
    const gameState = {
        players: {},
        guilds: {},
        wars: [],
        news: [],
        gate: 'CLOSED',
        chat: []
    };

    const seenChatIds = new Set();

    // ============================================
    // CLOUD SYNC FUNCTIONS
    // ============================================
    
    function updateCloudStatus(message, color = '#888') {
        const statusEl = document.getElementById('cloud-status');
        if (statusEl) {
            statusEl.textContent = 'Cloud: ' + message;
            statusEl.style.color = color;
        }

        // Update top-bar sync indicator
        const dot = document.getElementById('sync-dot');
        const label = document.getElementById('sync-label');
        const indicator = document.getElementById('sync-indicator');
        if (!dot || !label || !indicator) return;

        label.textContent = message;
        label.style.color = color;
        dot.style.background = color;
        indicator.title = 'Cloud: ' + message;

        // Pulse animation for active sync states
        const isSyncing = (message === 'Saving...' || message === 'Syncing...' || message === 'Loading...');
        dot.classList.toggle('syncing', isSyncing);

        // Glow effect for active states
        if (message === 'Synced' || message === 'Connected' || message === 'Reconnected!') {
            dot.style.boxShadow = '0 0 6px ' + color;
            setTimeout(() => { dot.style.boxShadow = 'none'; }, 2000);
        } else if (isSyncing) {
            dot.style.boxShadow = '0 0 6px ' + color;
        } else {
            dot.style.boxShadow = 'none';
        }
    }

    // Live "Connected ¬∑ Xs ago" ticker ‚Äî keeps the indicator feeling alive
    function formatTimeAgo(ms) {
        const sec = Math.floor((Date.now() - ms) / 1000);
        if (sec < 5) return 'just now';
        if (sec < 60) return sec + 's ago';
        const min = Math.floor(sec / 60);
        if (min < 60) return min + 'm ago';
        return Math.floor(min / 60) + 'h ago';
    }

    // This runs every 5 seconds and updates the indicator with a live timestamp
    // so the player always sees proof the connection is active
    let statusTickerTimer = null;
    function startStatusTicker() {
        if (statusTickerTimer) clearInterval(statusTickerTimer);
        statusTickerTimer = setInterval(() => {
            // Only update if we're in a "resting" state (not mid-sync or retrying)
            const label = document.getElementById('sync-label');
            const dot = document.getElementById('sync-dot');
            if (!label || !dot || !currentUser) return;

            const currentText = label.textContent;
            // Don't overwrite active states
            if (currentText.startsWith('Syncing') || currentText.startsWith('Saving') || 
                currentText.startsWith('Loading') || currentText.startsWith('Retrying') ||
                currentText === 'Reconnected!') return;

            if (cloudAvailable && lastSyncTime > 0) {
                const ago = formatTimeAgo(lastSyncTime);
                label.textContent = 'Connected ¬∑ ' + ago;
                label.style.color = '#44ff44';
                dot.style.background = '#44ff44';
                document.getElementById('sync-indicator').title = 'Cloud: Connected ¬∑ Last synced ' + ago;
            } else if (cloudFailCount > 0) {
                label.textContent = 'Retrying (' + cloudFailCount + ')';
                label.style.color = '#ff8844';
                dot.style.background = '#ff8844';
            } else {
                label.textContent = 'Connecting...';
                label.style.color = '#ffaa00';
                dot.style.background = '#ffaa00';
            }
        }, 5000);
    }

    function stopStatusTicker() {
        if (statusTickerTimer) {
            clearInterval(statusTickerTimer);
            statusTickerTimer = null;
        }
    }

    // ============================================
    // DESYNC BANNER ‚Äî shown when cloud is struggling, never hides retries
    // ============================================
    let desyncBannerDismissed = false; // User can dismiss, but it comes back if fails keep growing

    function showDesyncBanner() {
        const banner = document.getElementById('desync-banner');
        if (!banner || desyncBannerDismissed) return;
        banner.classList.remove('hidden');
        banner.style.display = 'flex';
        const countEl = document.getElementById('desync-fail-count');
        const statusEl = document.getElementById('desync-status');
        if (countEl) countEl.textContent = `(${cloudFailCount} failed attempt${cloudFailCount !== 1 ? 's' : ''})`;
        if (statusEl) statusEl.textContent = 'Retrying automatically...';
    }

    function hideDesyncBanner() {
        const banner = document.getElementById('desync-banner');
        if (!banner) return;
        banner.classList.add('hidden');
        banner.style.display = 'none';
        desyncBannerDismissed = false; // Reset dismiss so it can show again next time
    }

    function dismissDesyncBanner() {
        const banner = document.getElementById('desync-banner');
        if (!banner) return;
        banner.classList.add('hidden');
        banner.style.display = 'none';
        desyncBannerDismissed = true;
        // Reset dismiss after 2 minutes so banner can reappear if still failing
        setTimeout(() => { desyncBannerDismissed = false; }, 120000);
    }

    // ============================================
    // LOCAL STORAGE (Primary ‚Äî always works)
    // ============================================
    let cloudAvailable = false; // set true after first successful cloud request
    let cloudFailCount = 0; // Track consecutive failures (for UI only ‚Äî we never stop retrying) even after failures

    function getAccounts() {
        const realm = document.getElementById('realm-name')?.value.trim() || 'void-realm-default';
        const key = `void-accounts-${realm}`;
        const stored = localStorage.getItem(key);
        return stored ? JSON.parse(stored) : {};
    }

    function saveAccounts(accounts) {
        const realm = document.getElementById('realm-name')?.value.trim() || 'void-realm-default';
        const key = `void-accounts-${realm}`;
        localStorage.setItem(key, JSON.stringify(accounts));
    }

    function getLocalGameState() {
        const realm = document.getElementById('realm-name')?.value.trim() || 'void-realm-default';
        const key = `void-gamestate-${realm}`;
        const stored = localStorage.getItem(key);
        return stored ? JSON.parse(stored) : null;
    }

    function saveLocalGameState() {
        const realm = document.getElementById('realm-name')?.value.trim() || 'void-realm-default';
        const key = `void-gamestate-${realm}`;
        localStorage.setItem(key, JSON.stringify({
            players: gameState.players,
            guilds: gameState.guilds,
            wars: gameState.wars,
            news: gameState.news,
            gate: gameState.gate,
            chat: gameState.chat,
            lastModified: Date.now()
        }));
    }

    function loadLocalGameState() {
        const gs = getLocalGameState();
        if (gs) {
            if (gs.players) gameState.players = gs.players;
            if (gs.guilds) gameState.guilds = gs.guilds;
            if (gs.wars) gameState.wars = gs.wars;
            if (gs.news) gameState.news = gs.news;
            if (gs.gate) gameState.gate = gs.gate;
            if (gs.chat) {
                gameState.chat = gs.chat;
                gs.chat.forEach(msg => seenChatIds.add(msg.id));
            }
            return true;
        }
        return false;
    }

    function saveGameState() {
        markDirty();
    }

    // ============================================
    // CLOUD SYNC (Enhancement ‚Äî fails gracefully)
    // ============================================

    function fetchWithTimeout(url, options = {}, timeoutMs = 15000) {
        return Promise.race([
            fetch(url, options),
            new Promise((_, reject) => 
                setTimeout(() => reject(new Error('Request timed out')), timeoutMs)
            )
        ]);
    }

    function authDebug(msg) {
        const el = document.getElementById('auth-debug');
        if (el) {
            // msg is internal - but sanitize just in case
            el.innerHTML += msg + '<br>';
            el.scrollTop = el.scrollHeight;
        }
    }

    async function loadFromCloud() {
        try {
            updateCloudStatus('Loading...', '#ffaa00');
            authDebug('Attempting cloud load...');
            const realm = document.getElementById('realm-name').value.trim() || 'void-realm-default';
            
            const response = await fetchWithTimeout(
                `${CLOUD_CONFIG.webAppUrl}?realm=${encodeURIComponent(realm)}&action=load`,
                { redirect: 'follow' },
                20000
            );
            
            authDebug('Response status: ' + response.status);
            
            if (!response.ok) {
                throw new Error(`HTTP ${response.status}`);
            }
            
            const text = await response.text();
            authDebug('Response length: ' + text.length + ' chars');
            if (!text || text.trim().charAt(0) !== '{') {
                authDebug('Bad response: ' + text.substring(0, 100));
                throw new Error('Invalid response from server');
            }
            const data = JSON.parse(text);
            
            if (data.success && data.data) {
                if (data.data.accounts) {
                    saveAccounts(data.data.accounts);
                }
                
                if (data.data.gameState) {
                    const cloudGs = data.data.gameState;
                    const localGs = getLocalGameState();

                    // ‚îÄ‚îÄ SMART MERGE instead of pick-one ‚îÄ‚îÄ
                    // For PLAYERS: use cloud as base, but overlay local player data
                    // if local is newer (preserves other players' cloud progress)
                    if (cloudGs.players) {
                        // Start with cloud players (everyone else's latest data)
                        gameState.players = cloudGs.players;
                    }
                    // If we have local data, check if our specific player is newer locally
                    if (localGs && localGs.players && currentUser && localGs.players[currentUser]) {
                        const localTime = localGs.lastModified || 0;
                        const cloudTime = cloudGs.lastModified || data.data.timestamp || 0;
                        if (localTime > cloudTime) {
                            // Our local player data is newer ‚Äî keep it
                            authDebug('<span style="color:#44ff44">Local player data is newer, preserving local progress</span>');
                            gameState.players[currentUser] = localGs.players[currentUser];
                            isDirty = true; // Push our newer data to cloud
                        }
                    }

                    // For shared state: use cloud (it's the authoritative source)
                    if (cloudGs.guilds) gameState.guilds = cloudGs.guilds;
                    if (cloudGs.wars) gameState.wars = cloudGs.wars;
                    if (cloudGs.news) gameState.news = cloudGs.news;
                    if (cloudGs.gate) gameState.gate = cloudGs.gate;
                    
                    // For chat: merge by ID (never lose messages)
                    if (cloudGs.chat) {
                        const chatById = new Map();
                        (gameState.chat || []).forEach(msg => chatById.set(msg.id, msg));
                        cloudGs.chat.forEach(msg => {
                            chatById.set(msg.id, msg);
                            seenChatIds.add(msg.id);
                        });
                        gameState.chat = Array.from(chatById.values())
                            .sort((a, b) => a.time - b.time)
                            .slice(-100);
                    }
                }
                
                // Save merged state to localStorage as cache
                saveLocalGameState();
                cloudAvailable = true;
                cloudFailCount = 0; // Reset on success
                hideDesyncBanner();
                updateCloudStatus('Connected', '#44ff44');
                authDebug('<span style="color:#44ff44">Cloud loaded OK (merged)</span>');
                addLog("<span style='color:#44ff44'>‚úì Loaded from cloud</span>");
                return true;
            } else {
                // Cloud is empty ‚Äî try loading local data
                cloudAvailable = true;
                cloudFailCount = 0;
                hideDesyncBanner();
                if (loadLocalGameState()) {
                    authDebug('Cloud empty, loaded local data');
                    isDirty = true; // Push local data to cloud
                } else {
                    authDebug('Cloud connected but empty (no data yet)');
                }
                updateCloudStatus('Connected', '#44ff44');
                return true;
            }
        } catch (err) {
            cloudFailCount++;
            console.warn(`Cloud load failed (attempt ${cloudFailCount}):`, err.message);
            authDebug('<span style="color:#ff8844">Cloud error: ' + err.message + ' (attempt ' + cloudFailCount + ')</span>');
            // Don't set cloudAvailable=true yet (never confirmed working),
            // but don't give up ‚Äî startCloudSync retry timer will keep trying
            updateCloudStatus(`Retrying (${cloudFailCount})`, '#ff8844');
            
            // Fall back to localStorage for now
            if (loadLocalGameState()) {
                addLog("<span style='color:#ffaa00'>Playing locally ‚Äî cloud sync will keep retrying</span>");
            } else {
                addLog("<span style='color:#ffaa00'>New game started ‚Äî cloud sync will keep retrying</span>");
            }

            return false;
        }
    }

    async function saveToCloud(force = false) {
        // Always save to localStorage first (instant, never fails)
        saveLocalGameState();

        if (!force && !isDirty) {
            if (cloudAvailable) updateCloudStatus('Connected', '#44ff44');
            return true;
        }

        // Prevent overlapping saves ‚Äî if one is in flight, skip (it'll retry on next heartbeat)
        if (cloudSaveInProgress) {
            return true;
        }

        cloudSaveInProgress = true;

        try {
            updateCloudStatus('Syncing...', '#ffaa00');
            const realm = document.getElementById('realm-name').value.trim() || 'void-realm-default';
            
            // ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
            // STEP 1: Read fresh cloud state before writing
            // This prevents us from overwriting other players' progress
            // ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
            let cloudState = null;
            try {
                const loadResp = await fetchWithTimeout(
                    `${CLOUD_CONFIG.webAppUrl}?realm=${encodeURIComponent(realm)}&action=load`,
                    { redirect: 'follow' },
                    15000
                );
                if (loadResp.ok) {
                    const loadText = await loadResp.text();
                    if (loadText && loadText.trim().charAt(0) === '{') {
                        const loadData = JSON.parse(loadText);
                        if (loadData.success && loadData.data && loadData.data.gameState) {
                            cloudState = loadData.data.gameState;
                        }
                    }
                }
            } catch (readErr) {
                console.warn('Cloud read before save failed:', readErr.message);
                // Continue with full save as fallback
            }

            // ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
            // STEP 2: Merge ‚Äî overlay OUR changes onto fresh cloud state
            // This is the key fix: we don't blindly overwrite, we merge
            // ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
            let mergedState;
            if (cloudState && cloudState.players) {
                mergedState = mergeGameState(cloudState);
            } else {
                // No cloud state available ‚Äî send our full state (first save or cloud was empty)
                mergedState = {
                    players: gameState.players,
                    guilds: gameState.guilds,
                    wars: gameState.wars,
                    news: gameState.news,
                    gate: gameState.gate,
                    chat: gameState.chat,
                    lastModified: Date.now()
                };
            }

            // ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
            // STEP 3: Write merged state to cloud
            // ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
            const payload = {
                realm: realm,
                accounts: getAccounts(),
                gameState: mergedState,
                timestamp: Date.now()
            };
            
            const response = await fetchWithTimeout(CLOUD_CONFIG.webAppUrl, {
                method: 'POST',
                redirect: 'follow',
                headers: { 'Content-Type': 'text/plain' },
                body: JSON.stringify(payload)
            }, 20000);
            
            if (!response.ok) {
                throw new Error(`HTTP ${response.status}`);
            }
            
            const text = await response.text();
            const result = JSON.parse(text);
            
            if (result.success) {
                isDirty = false;
                lastSyncTime = Date.now();
                const wasDown = cloudFailCount > 0;
                cloudFailCount = 0; // Reset on success
                cloudAvailable = true;
                hideDesyncBanner();
                updateCloudStatus('Synced', '#44ff44');
                
                if (wasDown) {
                    addLog("<span style='color:#44ff44'>‚úì Cloud connection restored!</span>");
                }
                
                // Ticker will transition to "Connected ¬∑ Xs ago" automatically
                return true;
            } else {
                throw new Error(result.error || 'Save failed');
            }
        } catch (err) {
            cloudFailCount++;
            console.warn(`Cloud save failed (attempt ${cloudFailCount}):`, err.message);
            
            // Never disable cloud ‚Äî always keep retrying
            updateCloudStatus(`Retrying (${cloudFailCount})`, '#ff8844');
            
            // Show desync banner after 3 consecutive failures
            if (cloudFailCount >= 3) {
                showDesyncBanner();
            }
            
            // Schedule a retry with exponential backoff (cap at 30s)
            const backoff = Math.min(5000 * cloudFailCount, 30000);
            setTimeout(() => {
                if (currentUser) {
                    isDirty = true;
                    saveToCloud();
                }
            }, backoff);
            
            isDirty = true; // Keep dirty so next attempt actually saves
            return false;
        } finally {
            cloudSaveInProgress = false;
        }
    }

    // ============================================
    // MERGE ENGINE ‚Äî Prevents data loss from concurrent players
    // ============================================
    // Takes fresh cloud state and merges OUR local changes into it,
    // preserving other players' progress that arrived while we were playing.
    function mergeGameState(cloudState) {
        const merged = {};
        
        // ‚îÄ‚îÄ PLAYERS: Use cloud data for ALL other players, our data for current player ‚îÄ‚îÄ
        merged.players = {};
        // Start with all cloud players (this preserves everyone else's latest progress)
        if (cloudState.players) {
            Object.keys(cloudState.players).forEach(name => {
                merged.players[name] = cloudState.players[name];
            });
        }
        // Overlay our local player data (our session is authoritative for our own character)
        if (currentUser && gameState.players[currentUser]) {
            merged.players[currentUser] = gameState.players[currentUser];
        }
        // Also add any players that exist locally but not in cloud (new registrations)
        Object.keys(gameState.players).forEach(name => {
            if (!merged.players[name]) {
                merged.players[name] = gameState.players[name];
            }
        });

        // ‚îÄ‚îÄ GUILDS: Merge by using the most recently modified version of each guild ‚îÄ‚îÄ
        merged.guilds = {};
        const allGuildIds = new Set([
            ...Object.keys(cloudState.guilds || {}),
            ...Object.keys(gameState.guilds || {})
        ]);
        allGuildIds.forEach(gid => {
            const cloudGuild = (cloudState.guilds || {})[gid];
            const localGuild = (gameState.guilds || {})[gid];
            if (cloudGuild && localGuild) {
                // Both exist ‚Äî use whichever was modified more recently
                // For guild member lists, prefer the one with more members (avoids losing joins)
                const cloudMembers = (cloudGuild.members || []).length;
                const localMembers = (localGuild.members || []).length;
                merged.guilds[gid] = cloudMembers >= localMembers ? cloudGuild : localGuild;
            } else {
                merged.guilds[gid] = localGuild || cloudGuild;
            }
        });

        // ‚îÄ‚îÄ WARS: Use whichever has more progress (higher kill counts) ‚îÄ‚îÄ
        const cloudWars = cloudState.wars || [];
        const localWars = gameState.wars || [];
        if (localWars.length >= cloudWars.length) {
            merged.wars = localWars;
            // But update kill counts to max of cloud vs local (prevents reverting kills)
            cloudWars.forEach((cw, i) => {
                if (merged.wars[i]) {
                    merged.wars[i].kills1 = Math.max(merged.wars[i].kills1 || 0, cw.kills1 || 0);
                    merged.wars[i].kills2 = Math.max(merged.wars[i].kills2 || 0, cw.kills2 || 0);
                }
            });
        } else {
            merged.wars = cloudWars;
            localWars.forEach((lw, i) => {
                if (merged.wars[i]) {
                    merged.wars[i].kills1 = Math.max(merged.wars[i].kills1 || 0, lw.kills1 || 0);
                    merged.wars[i].kills2 = Math.max(merged.wars[i].kills2 || 0, lw.kills2 || 0);
                }
            });
        }

        // ‚îÄ‚îÄ CHAT: Merge by unique ID (never lose messages) ‚îÄ‚îÄ
        const chatById = new Map();
        (cloudState.chat || []).forEach(msg => chatById.set(msg.id, msg));
        (gameState.chat || []).forEach(msg => chatById.set(msg.id, msg));
        merged.chat = Array.from(chatById.values())
            .sort((a, b) => a.time - b.time)
            .slice(-100); // Keep last 100

        // ‚îÄ‚îÄ NEWS: Merge by unique content, prefer longer list ‚îÄ‚îÄ
        const newsSet = new Set();
        const allNews = [...(cloudState.news || []), ...(gameState.news || [])];
        merged.news = [];
        allNews.forEach(n => {
            const key = (n.text || '') + (n.time || '');
            if (!newsSet.has(key)) {
                newsSet.add(key);
                merged.news.push(n);
            }
        });
        merged.news = merged.news.slice(-50);

        // ‚îÄ‚îÄ GATE: Use local (admin controls this) ‚îÄ‚îÄ
        merged.gate = gameState.gate;

        merged.lastModified = Date.now();
        return merged;
    }

    // ============================================
    // CLOUD REFRESH ‚Äî Pull other players' changes without saving
    // ============================================
    async function refreshFromCloud() {
        if (!currentUser) return;
        
        try {
            const realm = document.getElementById('realm-name').value.trim() || 'void-realm-default';
            const response = await fetchWithTimeout(
                `${CLOUD_CONFIG.webAppUrl}?realm=${encodeURIComponent(realm)}&action=load`,
                { redirect: 'follow' },
                10000
            );
            
            if (!response.ok) return;
            
            const text = await response.text();
            if (!text || text.trim().charAt(0) !== '{') return;
            
            const data = JSON.parse(text);
            if (!data.success || !data.data || !data.data.gameState) return;
            
            const cloud = data.data.gameState;
            
            // Update OTHER players' data (never overwrite our own mid-session)
            if (cloud.players) {
                Object.keys(cloud.players).forEach(name => {
                    if (name !== currentUser) {
                        gameState.players[name] = cloud.players[name];
                    }
                });
            }
            
            // Update accounts cache
            if (data.data.accounts) {
                saveAccounts(data.data.accounts);
            }
            
            // Merge in new chat messages we haven't seen
            if (cloud.chat) {
                cloud.chat.forEach(msg => {
                    if (!seenChatIds.has(msg.id)) {
                        gameState.chat.push(msg);
                        seenChatIds.add(msg.id);
                    }
                });
                gameState.chat.sort((a, b) => a.time - b.time);
                if (gameState.chat.length > 100) {
                    gameState.chat = gameState.chat.slice(-100);
                }
            }
            
            // Merge guilds (add new ones, update existing with more members)
            if (cloud.guilds) {
                Object.keys(cloud.guilds).forEach(gid => {
                    const cloudGuild = cloud.guilds[gid];
                    const localGuild = gameState.guilds[gid];
                    if (!localGuild) {
                        gameState.guilds[gid] = cloudGuild;
                    } else {
                        // Update if cloud has more members
                        if ((cloudGuild.members || []).length > (localGuild.members || []).length) {
                            gameState.guilds[gid] = cloudGuild;
                        }
                    }
                });
                // Remove guilds that were disbanded in cloud
                Object.keys(gameState.guilds).forEach(gid => {
                    if (!cloud.guilds[gid]) {
                        delete gameState.guilds[gid];
                    }
                });
            }
            
            // Merge wars
            if (cloud.wars) {
                gameState.wars = cloud.wars;
            }
            
            // Merge news
            if (cloud.news) {
                const newsSet = new Set(gameState.news.map(n => (n.text || '') + (n.time || '')));
                cloud.news.forEach(n => {
                    const key = (n.text || '') + (n.time || '');
                    if (!newsSet.has(key)) {
                        gameState.news.push(n);
                    }
                });
                gameState.news = gameState.news.slice(-50);
            }

            if (cloud.gate) {
                gameState.gate = cloud.gate;
            }
            
            // Update local cache with merged data
            saveLocalGameState();
            
            // Track this as a successful sync for the status ticker
            lastSyncTime = Date.now();
            
            // Cloud is healthy ‚Äî reset fail counter and restore if it was down
            if (!cloudAvailable || cloudFailCount > 0) {
                const wasDown = !cloudAvailable;
                cloudAvailable = true;
                cloudFailCount = 0;
                hideDesyncBanner();
                if (wasDown) {
                    updateCloudStatus('Reconnected!', '#44ff44');
                    addLog("<span style='color:#44ff44'>‚úì Cloud connection restored!</span>");
                    // Push any pending local changes now that cloud is back
                    isDirty = true;
                    saveToCloud(true);
                }
            }
            
            // Refresh UI if on relevant tabs
            if (currentTab === 'chat') displayChat();
            if (currentTab === 'pvp') refreshPvpTargets();
            if (currentTab === 'leaderboard') loadLeaderboard();
            updatePlayerCount();
            
        } catch (err) {
            // Silent fail ‚Äî refresh is best-effort
            console.warn('Cloud refresh failed:', err.message);
        }
    }

    function markDirty(critical = false) {
        // Verify stat integrity before saving (skip if inside a gameAction)
        if (!_actionActive && p && p._sig && _lastGoodSnap) {
            if (!_verifyIntegrity()) {
                _revertStats();
                return; // Don't save tampered data
            }
        }

        isDirty = true;
        
        // Always save to localStorage immediately (fast & reliable)
        saveLocalGameState();
        
        // Clear existing cloud save timer
        if (autoSaveTimer) {
            clearTimeout(autoSaveTimer);
        }
        
        // Cloud save with appropriate delay:
        // Critical actions (purchases, PvP, boss kills) = 3 second delay
        // Routine actions (grinding, resting) = 15 second delay (configurable)
        const delay = critical ? 3000 : CLOUD_CONFIG.autoSaveDelay;
        autoSaveTimer = setTimeout(() => {
            saveToCloud();
        }, delay);
    }

    function startCloudSync() {
        if (cloudSyncTimer) clearInterval(cloudSyncTimer);
        if (cloudRefreshTimer) clearInterval(cloudRefreshTimer);
        
        // Periodic cloud SAVE (heartbeat ‚Äî pushes our changes, always runs)
        cloudSyncTimer = setInterval(() => {
            if (currentUser) saveToCloud();
        }, CLOUD_CONFIG.heartbeatInterval);
        
        // Periodic cloud REFRESH (pulls other players' changes, also doubles as reconnect)
        // Always runs ‚Äî refreshFromCloud will restore cloudAvailable if server responds
        cloudRefreshTimer = setInterval(() => {
            if (currentUser) refreshFromCloud();
        }, CLOUD_CONFIG.cloudRefreshInterval);
        
        const mode = cloudAvailable ? 'Cloud sync' : 'Local autosave (retrying cloud)';
        addLog(`<span style='color:#44ff44'>${mode} started</span>`);
        startStatusTicker();
    }

    function stopCloudSync() {
        if (cloudSyncTimer) {
            clearInterval(cloudSyncTimer);
            cloudSyncTimer = null;
        }
        if (cloudRefreshTimer) {
            clearInterval(cloudRefreshTimer);
            cloudRefreshTimer = null;
        }
        if (autoSaveTimer) {
            clearTimeout(autoSaveTimer);
            autoSaveTimer = null;
        }
        stopStatusTicker();
    }

    // ============================================
    // AUTH FUNCTIONS
    // ============================================
    function switchAuthTab(tab) {
        document.getElementById('auth-login').classList.toggle('hidden', tab !== 'login');
        document.getElementById('auth-register').classList.toggle('hidden', tab !== 'register');
        document.getElementById('tab-login-btn').classList.toggle('active', tab === 'login');
        document.getElementById('tab-register-btn').classList.toggle('active', tab === 'register');
        document.getElementById('auth-error').innerText = '';
        document.getElementById('auth-success').innerText = '';
    }

    async function doLogin() {
        const username = document.getElementById('login-username').value.trim();
        const password = document.getElementById('login-password').value;
        const errorDiv = document.getElementById('auth-error');
        const loginBtn = document.querySelector('#auth-login .action-btn');
        
        errorDiv.innerText = '';
        
        if (!username || !password) {
            errorDiv.innerText = 'Enter username and password.';
            return;
        }
        
        if (!isValidUsername(username)) {
            errorDiv.innerText = 'Invalid username format.';
            return;
        }
        
        // Show loading state
        const origText = loginBtn.textContent;
        loginBtn.textContent = 'Connecting...';
        loginBtn.disabled = true;

        try {
            // Load from cloud first
            await loadFromCloud();
        
            const accounts = getAccounts();
            const accountNames = Object.keys(accounts);
            authDebug('Local accounts found: ' + (accountNames.length ? accountNames.join(', ') : 'none'));
        
            if (!accounts[username]) {
                errorDiv.innerText = 'Account not found. Register first or clear local data and re-register.';
                authDebug('<span style="color:#ff4444">Account "' + sanitize(username) + '" not found</span>');
                return;
            }
        
            const hashedPw = await hashPassword(password, username);
            // Support both hashed and legacy plaintext passwords (auto-upgrade)
            if (accounts[username].password !== hashedPw && accounts[username].password !== password) {
                errorDiv.innerText = 'Incorrect password.';
                authDebug('<span style="color:#ff4444">Wrong password for "' + sanitize(username) + '"</span>');
                return;
            }
            // Auto-upgrade plaintext passwords to hashed
            if (accounts[username].password === password && accounts[username].password !== hashedPw) {
                accounts[username].password = hashedPw;
                saveAccounts(accounts);
            }
        
            authDebug('Password OK, logging in as ' + username);
            
            // Check if banned
            if (gameState.players[username] && gameState.players[username].banned) {
                errorDiv.innerText = 'This account has been banned from the realm.';
                authDebug('<span style="color:#ff4444">Account "' + username + '" is banned</span>');
                return;
            }
            
            currentUser = username;
        
            if (!gameState.players[username]) {
                authDebug('Creating new player data...');
                gameState.players[username] = {
                    race: accounts[username].race,
                    level: 1,
                    xp: 0,
                    hp: 100,
                    maxHp: 100,
                    str: accounts[username].race === 'Hollow' ? 11 : 10,
                    wis: accounts[username].race === 'Wraith' ? 11 : 10,
                    gold: 0,
                    guild: null,
                    kills: 0,
                    deaths: 0,
                    online: true,
                    lastSeen: Date.now(),
                    createdAt: Date.now(),
                    bossData: {},
                    trophies: [],
                    voidEntityTier: 0,
                    dailyQuests: null,
                    dailyQuestsLastReset: 0,
                    warTrophyWins: 0,
                    totalGoldSpent: 0,
                    totalBossKills: 0
                };
                markDirty();
            } else {
                authDebug('Existing player found, updating online status...');
                gameState.players[username].online = true;
                gameState.players[username].lastSeen = Date.now();
                // Migrate new fields for existing players
                const pl = gameState.players[username];
                if (pl.voidEntityTier === undefined) pl.voidEntityTier = 0;
                if (pl.dailyQuests === undefined) pl.dailyQuests = null;
                if (pl.dailyQuestsLastReset === undefined) pl.dailyQuestsLastReset = 0;
                if (pl.warTrophyWins === undefined) pl.warTrophyWins = 0;
                if (pl.totalGoldSpent === undefined) pl.totalGoldSpent = 0;
                if (pl.totalBossKills === undefined) pl.totalBossKills = 0;
                markDirty();
            }
        
            p = gameState.players[username];
            authDebug('Player loaded: Lv' + p.level + ', ' + p.gold + 'g');
        
            document.getElementById('auth-screen').classList.add('hidden');
            authDebug('Auth screen hidden, refreshing UI...');
            refreshUI();
            startCloudSync();
            updatePlayerCount();
        
            if (username === ADMIN) {
                document.getElementById('nav-admin').classList.remove('hidden');
            }
        
            addLog(`<span style="color:var(--gold)">Welcome, ${sanitize(username)}.</span>`);
            sendSystemChat(`‚öî ${username} has entered the Void.`);
            _stampIntegrity();
            checkAndResetDailyQuests();
            authDebug('Login complete!');
        } catch (err) {
            console.warn('Login error:', err);
            authDebug('<span style="color:#ff4444">LOGIN ERROR: ' + err.message + '</span>');
            errorDiv.innerText = 'Login error: ' + err.message;
        } finally {
            loginBtn.textContent = origText;
            loginBtn.disabled = false;
        }
    }

    async function doRegister() {
        const username = document.getElementById('reg-username').value.trim();
        const password = document.getElementById('reg-password').value;
        const password2 = document.getElementById('reg-password2').value;
        const race = document.getElementById('race-sel').value;
        const errorDiv = document.getElementById('auth-error');
        const successDiv = document.getElementById('auth-success');
        const regBtn = document.querySelector('#auth-register .action-btn');
        
        errorDiv.innerText = '';
        successDiv.innerText = '';
        
        if (!username || !password) {
            errorDiv.innerText = 'Enter a username and password.';
            return;
        }
        
        if (!isValidUsername(username)) {
            errorDiv.innerText = 'Username must be 3-20 characters, alphanumeric/underscores/hyphens only.';
            return;
        }
        
        if (password.length < 4) {
            errorDiv.innerText = 'Password must be at least 4 characters.';
            return;
        }
        
        if (password !== password2) {
            errorDiv.innerText = 'Passwords do not match.';
            return;
        }

        const origText = regBtn.textContent;
        regBtn.textContent = 'Creating...';
        regBtn.disabled = true;
        
        try {
            // Load from cloud first
            await loadFromCloud();
            
            const accounts = getAccounts();
            
            if (accounts[username]) {
                errorDiv.innerText = 'Username already taken.';
                return;
            }
            
            const hashedPw = await hashPassword(password, username);
            accounts[username] = { password: hashedPw, race };
            saveAccounts(accounts);
            markDirty();
            
            successDiv.innerText = '‚úì Account created! You may now login.';
            
            setTimeout(() => {
                switchAuthTab('login');
                document.getElementById('login-username').value = username;
                document.getElementById('login-password').focus();
            }, 1500);
        } catch (err) {
            console.warn('Register error:', err);
            errorDiv.innerText = 'Registration error: ' + err.message;
        } finally {
            regBtn.textContent = origText;
            regBtn.disabled = false;
        }
    }

    // ============================================
    // UI FUNCTIONS
    // ============================================
    function refreshUI() {
        document.getElementById('stat-level').innerText = p.level;
        document.getElementById('stat-xp').innerText = p.xp;
        document.getElementById('stat-xp-next').innerText = p.level * 100;
        
        const hpEl = document.getElementById('stat-hp');
        hpEl.innerText = p.hp;
        document.getElementById('stat-maxhp').innerText = p.maxHp;
        const hpPercent = p.hp / p.maxHp;
        if (hpPercent <= 0) {
            hpEl.style.color = '#ff0000';
        } else if (hpPercent <= 0.25) {
            hpEl.style.color = '#ff4444';
        } else if (hpPercent <= 0.5) {
            hpEl.style.color = '#ffaa00';
        } else {
            hpEl.style.color = '';
        }
        
        document.getElementById('stat-str').innerText = p.str;
        document.getElementById('stat-wis').innerText = p.wis;
        const wisMult = document.getElementById('stat-wis-mult');
        if (wisMult) wisMult.textContent = `(√ó${(1 + p.wis / 100).toFixed(2)} XP)`;
        document.getElementById('stat-gold').innerText = p.gold;
        
        const guildSpan = document.getElementById('stat-guild');
        if (p.guild) {
            const guild = gameState.guilds[p.guild];
            guildSpan.innerHTML = `<span style="color:#4af">„Äê${guild ? sanitize(guild.tag) : sanitize(p.guild)}„Äë</span>`;
        } else {
            guildSpan.innerHTML = '';
        }
    }

    function addLog(html) {
        const log = document.getElementById('game-log');
        if (!log) return;
        const entry = document.createElement('div');
        entry.innerHTML = `<span style="color:#555">[${new Date().toLocaleTimeString()}]</span> ${html}`;
        log.appendChild(entry);
        log.scrollTop = log.scrollHeight;
    }

    function goTab(tabName) {
        // If leaving bosses tab while in a fight, reset the boss
        if (currentTab === 'bosses' && tabName !== 'bosses' && activeBossFight) {
            resetActiveBoss();
        }

        currentTab = tabName;
        document.querySelectorAll('.content > div').forEach(el => el.classList.add('hidden'));
        const target = document.getElementById('tab-' + tabName);
        if (target) target.classList.remove('hidden');
        
        // Auto-scroll tavern chat to bottom when opening it
        if (tabName === 'chat') {
            displayChat();
            setTimeout(() => {
                const chatLog = document.getElementById('chat-log');
                if (chatLog) chatLog.scrollTop = chatLog.scrollHeight;
            }, 50);
        }
        
        // Load profile data when opening profile tab
        if (tabName === 'profile' && p) {
            const displayNameInput = document.getElementById('profile-displayname');
            const avatarInput = document.getElementById('profile-avatar');
            const bioInput = document.getElementById('profile-bio');
            
            if (displayNameInput) {
                displayNameInput.value = p.displayName || '';
            }
            
            // Render level-locked avatar selector
            renderAvatarSelector();
            
            if (avatarInput) {
                avatarInput.value = p.avatar || '‚öîÔ∏è';
            }
            
            if (bioInput) {
                bioInput.value = p.bio || '';
            }
            
            // Render trophy collection
            const trophyContainer = document.getElementById('profile-trophies');
            if (trophyContainer) {
                if (p.trophies && p.trophies.length > 0) {
                    trophyContainer.innerHTML = renderTrophies(p.trophies);
                } else {
                    trophyContainer.innerHTML = '<p style="color:#666;">No trophies yet. Defeat bosses to earn them!</p>';
                }
            }
        }
        
        closeMenu();
    }

    function toggleMenu() {
        document.getElementById('main-nav').classList.toggle('open');
        document.getElementById('nav-overlay').classList.toggle('open');
    }

    function closeMenu() {
        document.getElementById('main-nav').classList.remove('open');
        document.getElementById('nav-overlay').classList.remove('open');
    }

    function updatePlayerCount() {
        const online = Object.values(gameState.players).filter(pl => {
            const age = Date.now() - (pl.lastSeen || 0);
            return pl.online && age < 120000;
        }).length;
        
        const countEl = document.getElementById('player-count');
        if (countEl) countEl.innerText = online;
    }

    // ============================================
    // GRINDING
    // ============================================
    function doGrind() {
        if (rateLimited('grind', 500)) return;
        
        // Check if already dead
        if (p.hp <= 0) {
            addLog(`<span style="color:#ff4444;">You are too weak to fight. Rest to recover!</span>`);
            return;
        }
        
        playAttackSound();
        gameAction(() => {
        const baseXpGain = Math.floor(10 + Math.random() * 20);
        const wisMultiplier = 1 + (p.wis / 100);
        const xpGain = Math.floor(baseXpGain * wisMultiplier);
        const goldGain = Math.floor(5 + Math.random() * 15);
        
        // Enemies deal flat damage ‚Äî higher max HP = more fights before resting
        const damage = 20;
        
        p.xp += xpGain;
        p.gold += goldGain;
        p.kills++;
        p.hp -= damage;
        
        // Track daily quest progress
        trackQuestProgress('minions', 1);
        
        // Track war kills if in active war
        if (p.guild) {
            checkAndUpdateWarKills(p.guild);
        }
        
        addLog(`You slay a Void Wraith. <span style="color:var(--gold)">+${xpGain} XP, +${goldGain} Gold</span> <span style="color:#ff6666;">-${damage} HP</span>`);
        
        // Check for death ‚Äî lose all gold
        if (p.hp <= 0) {
            p.hp = 0;
            const goldLost = p.gold;
            p.gold = 0;
            addLog(`<span style="color:#ff4444; font-weight:bold;">‚ò† You have fallen! Your ${goldLost} gold scatters into the void...</span>`);
            showToast('defeat', '‚ò† Fallen!', 'You collapsed in the Frontier', `${goldLost > 0 ? `Lost ${goldLost} gold ‚Äî Rest to recover` : 'Rest to recover'}`);
        }
        
        while (p.xp >= p.level * 100) {
            p.xp -= p.level * 100;
            p.level++;
            p.maxHp += 20;
            p.hp = p.maxHp;
            p.str += 2;
            p.wis += 2;
            addLog(`<span style="color:#4af; font-weight:bold;">LEVEL UP! You are now level ${p.level}. HP fully restored!</span>`);
        }
        
        refreshUI();
        markDirty();
        });
    }

    function doRest() {
        gameAction(() => {
        const healAmount = Math.floor(p.maxHp * 0.5);
        const oldHp = p.hp;
        p.hp = Math.min(p.maxHp, p.hp + healAmount);
        const actualHeal = p.hp - oldHp;
        
        if (actualHeal === 0) {
            addLog(`<span style="color:#888;">You are already at full health.</span>`);
        } else {
            addLog(`<span style="color:#44ff44;">You rest and recover. +${actualHeal} HP (${p.hp}/${p.maxHp})</span>`);
            refreshUI();
            markDirty();
        }
        });
    }

    // ============================================
    // LEADERBOARD
    // ============================================
    function loadLeaderboard() {
        const list = document.getElementById('leaderboard-list');
        if (!list) return;
        
        const searchTerm = (document.getElementById('lead-search')?.value || '').trim().toLowerCase();
        
        let players = Object.entries(gameState.players)
            .sort((a, b) => b[1].level - a[1].level || b[1].xp - a[1].xp);
        
        if (searchTerm) {
            players = players.filter(([name, data]) => {
                const displayName = (data.displayName || name).toLowerCase();
                return name.toLowerCase().includes(searchTerm) || displayName.includes(searchTerm);
            });
        }
        
        players = players.slice(0, 30);
        
        if (players.length === 0) {
            list.innerHTML = '<p style="color:#666;">No players yet.</p>';
            return;
        }
        
        let html = '<table style="width:100%; border-collapse: collapse;">';
        html += '<tr style="border-bottom:1px solid #333;"><th style="text-align:left; padding:8px;">Rank</th><th style="text-align:left;">Name</th><th>Level</th><th>Guild</th><th>Kills</th></tr>';
        
        players.forEach(([name, data], i) => {
            const guildTag = data.guild && gameState.guilds[data.guild] ? `„Äê${sanitize(gameState.guilds[data.guild].tag)}„Äë` : '-';
            const isOnline = data.online && (Date.now() - (data.lastSeen || 0)) < 120000;
            const onlineIndicator = isOnline ? '<span style="color:#44ff44;">‚óè</span>' : '<span style="color:#666;">‚óè</span>';
            const displayName = sanitize(data.displayName || name);
            const avatar = data.avatar || '‚öîÔ∏è';
            const safeName = safeAttr(name);
            
            html += `<tr style="border-bottom:1px solid #222;">`;
            html += `<td style="padding:8px;">#${i + 1}</td>`;
            html += `<td>${onlineIndicator} ${avatar} <span class="name-link" data-player="${safeName}" onclick="window._showPlayer(this.dataset.player)">${displayName}</span></td>`;
            html += `<td style="text-align:center;">${data.level}</td>`;
            html += `<td style="text-align:center; color:#4af;">${guildTag}</td>`;
            html += `<td style="text-align:center;">${data.kills || 0}</td>`;
            html += `</tr>`;
        });
        
        html += '</table>';
        list.innerHTML = html;
    }

    function showPlayerCard(username) {
        const pl = gameState.players[username];
        if (!pl) return;
        
        _lastViewTab = currentTab;
        
        const guildName = pl.guild && gameState.guilds[pl.guild] ? `„Äê${sanitize(gameState.guilds[pl.guild].tag)}„Äë${sanitize(gameState.guilds[pl.guild].name)}` : 'None';
        const displayName = sanitize(pl.displayName || username);
        const avatar = pl.avatar || '‚öîÔ∏è';
        const bio = sanitize(pl.bio || 'No bio set.');
        const isOnline = pl.online && (Date.now() - (pl.lastSeen || 0)) < 120000;
        const onlineText = isOnline ? '<span style="color:#44ff44;">‚óè Online</span>' : '<span style="color:#666;">‚óè Offline</span>';
        
        let html = `<div class="profile-page-header">`;
        html += `<div class="profile-page-avatar">${avatar}</div>`;
        html += `<div>`;
        html += `<h2 style="margin:0; color:var(--gold);">${displayName}</h2>`;
        html += `<div style="color:#888; font-size:0.85rem; margin-top:4px;">${sanitize(username)} ¬∑ ${sanitize(pl.race)} ¬∑ ${onlineText}</div>`;
        html += `<div style="color:#666; font-size:0.85rem; margin-top:2px;">Guild: <span style="color:#4af;">${guildName}</span></div>`;
        html += `</div></div>`;
        
        if (bio !== 'No bio set.') {
            html += `<div style="border-left:3px solid #333; padding:10px 15px; margin-bottom:20px; color:#aaa; font-style:italic;">"${bio}"</div>`;
        }
        
        html += `<div class="profile-page-stats">`;
        html += `<div class="profile-stat-card"><div class="stat-label">Level</div><div class="stat-value">${pl.level}</div></div>`;
        html += `<div class="profile-stat-card"><div class="stat-label">HP</div><div class="stat-value">${pl.hp}/${pl.maxHp}</div></div>`;
        html += `<div class="profile-stat-card"><div class="stat-label">STR</div><div class="stat-value">${pl.str}</div></div>`;
        html += `<div class="profile-stat-card"><div class="stat-label">WIS (XP Mult)</div><div class="stat-value">${pl.wis} <span style="font-size:0.7rem; color:#888;">√ó${(1 + pl.wis / 100).toFixed(2)}</span></div></div>`;
        html += `<div class="profile-stat-card"><div class="stat-label">Gold</div><div class="stat-value">${(pl.gold || 0).toLocaleString()}</div></div>`;
        html += `<div class="profile-stat-card"><div class="stat-label">Total Kills</div><div class="stat-value">${(pl.kills || 0).toLocaleString()}</div></div>`;
        html += `</div>`;
        
        // Show trophies
        html += renderTrophies(pl.trophies);
        
        const container = document.getElementById('playerview-content');
        if (container) container.innerHTML = html;
        goTab('playerview');
    }

    // ============================================
    // SHOP
    // ============================================
    function refreshShop() {
        const container = document.getElementById('shop-items');
        if (!container) return;
        
        const goldDisplay = document.getElementById('shop-gold');
        if (goldDisplay) goldDisplay.innerText = p.gold || 0;
        
        const items = [
            { name: 'Strength Elixir', cost: 200, desc: '+2 STR permanently', effect: () => { p.str += 2; } },
            { name: 'Wisdom Scroll', cost: 200, desc: '+2 WIS permanently', effect: () => { p.wis += 2; } },
            { name: 'Vitality Potion', cost: 300, desc: '+20 Max HP permanently', effect: () => { p.maxHp += 20; p.hp += 20; } },
            { name: 'Warrior\'s Blessing', cost: 500, desc: '+5 STR permanently', effect: () => { p.str += 5; } },
            { name: 'Sage\'s Blessing', cost: 500, desc: '+5 WIS permanently', effect: () => { p.wis += 5; } },
            { name: 'Titan\'s Heart', cost: 800, desc: '+50 Max HP permanently', effect: () => { p.maxHp += 50; p.hp += 50; } },
            { name: 'Divine Elixir', cost: 1000, desc: '+10 STR, +10 WIS permanently', effect: () => { p.str += 10; p.wis += 10; } }
        ];
        
        let html = '<div style="display:flex; flex-wrap:wrap; gap:10px;">';
        items.forEach((item, i) => {
            const canAfford = p.gold >= item.cost;
            const borderColor = canAfford ? '#333' : '#222';
            const costColor = canAfford ? 'var(--gold)' : '#ff4444';
            html += `<div style="border:1px solid ${borderColor}; padding:15px; flex:1; min-width:200px;${!canAfford ? ' opacity:0.6;' : ''}">`;
            html += `<h3 style="margin:0 0 5px 0; color:var(--gold);">${item.name}</h3>`;
            html += `<p style="color:#888; font-size:0.85rem; margin:5px 0;">${item.desc}</p>`;
            html += `<p style="color:${costColor}; font-weight:bold; margin:10px 0;">Cost: ${item.cost} Gold</p>`;
            html += `<button class="action-btn" onclick="buyItem(${i})">${canAfford ? 'Purchase' : 'Cannot Afford'}</button>`;
            html += `</div>`;
        });
        html += '</div>';
        
        container.innerHTML = html;
        window.shopItems = items;
    }

    function buyItem(index) {
        if (rateLimited('buy', 1000)) return;
        const item = window.shopItems[index];
        if (!item) return;
        
        if (p.gold < item.cost) {
            showToast('error', 'Not Enough Gold', `You need ${item.cost} gold`, `You have ${p.gold} gold`);
            return;
        }
        
        gameAction(() => {
        p.gold -= item.cost;
        if (!p.totalGoldSpent) p.totalGoldSpent = 0;
        p.totalGoldSpent += item.cost;
        trackQuestProgress('gold', item.cost);
        item.effect();
        addLog(`<span style="color:var(--gold);">Purchased ${item.name}.</span>`);
        showToast('purchase', 'üõí Purchased!', item.name, `${item.desc} ¬∑ -${item.cost} Gold`);
        refreshUI();
        refreshShop();
        markDirty(true);
        });
    }

    // ============================================
    // PVP
    // ============================================
    function refreshPvpTargets() {
        const container = document.getElementById('pvp-targets');
        if (!container) return;
        
        const myPowerBase = p.level * 10 + p.str * 5;
        
        const targets = Object.entries(gameState.players)
            .filter(([name]) => name !== currentUser)
            .sort((a, b) => {
                const aPower = a[1].level * 10 + a[1].str * 5;
                const bPower = b[1].level * 10 + b[1].str * 5;
                const aWin = myPowerBase / (myPowerBase + aPower);
                const bWin = myPowerBase / (myPowerBase + bPower);
                const aScore = aWin * (a[1].gold || 0);
                const bScore = bWin * (b[1].gold || 0);
                return bScore - aScore;
            });
        
        if (targets.length === 0) {
            container.innerHTML = '<p style="color:#666;">No other players available.</p>';
            return;
        }
        
        let html = '';
        targets.slice(0, 10).forEach(([name, data]) => {
            const isOnline = data.online && (Date.now() - (data.lastSeen || 0)) < 120000;
            const onlineText = isOnline ? '<span style="color:#44ff44;">‚óè</span>' : '<span style="color:#666;">‚óã</span>';
            const displayName = sanitize(data.displayName || name);
            const avatar = data.avatar || '‚öîÔ∏è';
            const hasGold = (data.gold || 0) > 0;
            const safeName = safeAttr(name);
            
            const myPower = p.level * 10 + p.str * 5;
            const theirPower = data.level * 10 + data.str * 5;
            const winChance = Math.round((myPower / (myPower + theirPower)) * 100);
            const chanceColor = winChance >= 60 ? '#44ff44' : winChance >= 40 ? '#ffaa00' : '#ff4444';
            
            html += `<div style="border:1px solid ${hasGold ? '#333' : '#222'}; padding:12px; margin-bottom:8px; display:flex; justify-content:space-between; align-items:center; flex-wrap:wrap; gap:8px;${!hasGold ? ' opacity:0.5;' : ''}">`;
            html += `<span>${onlineText} ${avatar} <span class="name-link" data-player="${safeName}" onclick="window._showPlayer(this.dataset.player)">${displayName}</span> (Lv ${data.level}) ¬∑ <span style="color:var(--gold);">‚öú ${(data.gold || 0).toLocaleString()}</span></span>`;
            if (hasGold) {
                html += `<span style="display:flex; align-items:center; gap:10px;"><span style="color:${chanceColor}; font-size:0.8rem;">${winChance}% win</span>`;
                html += `<button class="action-btn" data-target="${safeName}" onclick="window._attackPlayer(this.dataset.target)">‚öî Attack</button></span>`;
            } else {
                html += `<span style="color:#666; font-size:0.8rem;">No gold to steal</span>`;
            }
            html += `</div>`;
        });
        
        container.innerHTML = html;
    }

    function attackPlayer(targetName) {
        if (rateLimited('pvp', 2000)) return;
        const target = gameState.players[targetName];
        if (!target) return;
        
        if ((target.gold || 0) <= 0) {
            showToast('error', 'No Loot', 'This player has no gold to steal', '');
            return;
        }
        
        const targetDisplay = sanitize(target.displayName || targetName);
        const myDisplay = sanitize(p.displayName || currentUser);
        
        const myPower = p.level * 10 + p.str * 5;
        const theirPower = target.level * 10 + target.str * 5;
        const chance = myPower / (myPower + theirPower);
        
        playAttackSound();
        gameAction(() => {
        if (Math.random() < chance) {
            const goldStolen = target.gold;
            const xpGain = target.level * 20;
            
            p.gold += goldStolen;
            p.xp += xpGain;
            p.kills++;
            target.gold = 0;
            target.deaths++;
            
            addLog(`<span style="color:#44ff44;">Victory!</span> You defeated ${targetDisplay}. <span style="color:var(--gold)">+${goldStolen} Gold, +${xpGain} XP</span>`);
            sendSystemChat(`‚öî ${myDisplay} has defeated ${targetDisplay} in the Arena!`);
            showToast('victory', '‚öî Victory!', `You defeated ${targetDisplay}`, `+${goldStolen} Gold ¬∑ +${xpGain} XP`);
        } else {
            const goldLost = p.gold;
            p.gold = 0;
            p.deaths++;
            target.kills++;
            target.gold += goldLost;
            
            addLog(`<span style="color:#ff4444;">Defeat!</span> ${targetDisplay} bested you. <span style="color:#ff4444;">-${goldLost} Gold</span>`);
            showToast('defeat', 'üíÄ Defeat', `${targetDisplay} bested you`, `${goldLost > 0 ? `-${goldLost} Gold stolen` : 'No gold to lose'}`);
        }
        
        refreshUI();
        refreshPvpTargets();
        markDirty(true);
        });
    }

    function showToast(type, title, message, detail) {
        // Remove any existing toasts
        document.querySelectorAll('.result-toast').forEach(t => t.remove());
        
        const validTypes = ['victory','defeat','purchase','error'];
        const safeType = validTypes.includes(type) ? type : 'error';
        
        const toast = document.createElement('div');
        toast.className = `result-toast ${safeType}`;
        toast.innerHTML = `<div class="toast-title">${sanitize(title)}</div><div>${sanitize(message)}</div>${detail ? `<div class="toast-detail">${sanitize(detail)}</div>` : ''}`;
        document.body.appendChild(toast);
        
        setTimeout(() => { if (toast.parentNode) toast.remove(); }, 3000);
    }

    // ============================================
    // GUILD SYSTEM
    // ============================================
    function refreshGuildUI() {
        const container = document.getElementById('guild-content');
        if (!container) return;
        
        // Build guild search (always shown)
        let searchHtml = '<div style="margin-bottom:15px;">';
        searchHtml += '<input type="text" id="guild-search" placeholder="Search guilds..." style="width:100%; max-width:300px;" oninput="refreshGuildUI()">';
        searchHtml += '</div>';
        
        const guildSearchTerm = (document.getElementById('guild-search')?.value || '').trim().toLowerCase();
        
        if (!p.guild) {
            let html = searchHtml;
            html += '<h3>You are not in a guild.</h3>';
            html += '<button class="action-btn" onclick="showCreateGuild()">Create Guild (500 Gold)</button>';
            html += '<div style="margin-top:20px;"><h4>Existing Guilds</h4>';
            
            let guilds = Object.entries(gameState.guilds);
            if (guildSearchTerm) {
                guilds = guilds.filter(([id, g]) => g.name.toLowerCase().includes(guildSearchTerm) || g.tag.toLowerCase().includes(guildSearchTerm) || (g.blurb || '').toLowerCase().includes(guildSearchTerm));
            }
            if (guilds.length === 0) {
                html += '<p style="color:#666;">No guilds found.</p>';
            } else {
                guilds.forEach(([id, guild]) => {
                    const isFull = guild.members.length >= 10;
                    const safeGuildId = safeAttr(id);
                    html += `<div style="border:1px solid #333; padding:10px; margin-bottom:5px;">`;
                    html += `<strong style="color:#4af;">„Äê${sanitize(guild.tag)}„Äë${sanitize(guild.name)}</strong> - ${guild.members.length}/10 members`;
                    if (guild.blurb) {
                        html += `<div style="color:#999; font-size:0.85rem; margin-top:4px; font-style:italic;">"${sanitize(guild.blurb)}"</div>`;
                    }
                    if (isFull) {
                        html += ` <span style="color:#ff4444; font-size:0.85rem;">(Full)</span>`;
                    } else {
                        html += ` <button class="action-btn" data-guild="${safeGuildId}" onclick="window._joinGuild(this.dataset.guild)">Request to Join</button>`;
                    }
                    html += `</div>`;
                });
            }
            html += '</div>';
            container.innerHTML = html;
        } else {
            const guild = gameState.guilds[p.guild];
            if (!guild) {
                p.guild = null;
                markDirty();
                refreshGuildUI();
                return;
            }
            
            const isLeader = guild.leader === currentUser;
            
            let html = searchHtml;
            html += `<h3 style="color:#4af;">„Äê${sanitize(guild.tag)}„Äë${sanitize(guild.name)}</h3>`;
            html += `<p>Leader: ${sanitize(guild.leader)}</p>`;
            
            // Show blurb
            if (guild.blurb) {
                html += `<div style="border-left:3px solid #333; padding:8px 12px; margin:10px 0; color:#999; font-style:italic;">"${sanitize(guild.blurb)}"</div>`;
            }
            
            // Leader can edit blurb
            if (isLeader) {
                html += `<div style="margin:10px 0;">`;
                html += `<label style="display:block; color:#888; font-size:0.8rem; margin-bottom:4px;">Guild Tagline</label>`;
                html += `<div style="display:flex; gap:5px; align-items:flex-start;">`;
                html += `<textarea id="guild-blurb-input" placeholder="Add a tagline or requirements..." style="flex:1; height:50px; background:#111; border:1px solid #333; color:white; padding:8px; font-family:inherit; resize:vertical; font-size:0.85rem;">${guild.blurb || ''}</textarea>`;
                html += `<button class="action-btn" onclick="saveGuildBlurb()" style="white-space:nowrap;">Save</button>`;
                html += `</div>`;
                html += `<p style="color:#555; font-size:0.75rem; margin-top:3px;">Max 150 chars. Visible to all players.</p>`;
                html += `</div>`;
            }
            
            html += `<p>Members (${guild.members.length}/10):</p>`;
            
            // List members with kick buttons for leader
            html += '<div style="margin:10px 0;">';
            guild.members.forEach(member => {
                const memberData = gameState.players[member];
                const memberDisplay = sanitize(memberData?.displayName || member);
                const memberAvatar = memberData?.avatar || '‚öîÔ∏è';
                const isLeaderMember = member === guild.leader;
                const safeMember = safeAttr(member);
                
                html += `<div style="display:flex; justify-content:space-between; align-items:center; padding:6px 10px; border-bottom:1px solid #222;">`;
                html += `<span>${memberAvatar} <span class="name-link" data-player="${safeMember}" onclick="window._showPlayer(this.dataset.player)">${memberDisplay}</span>${isLeaderMember ? ' <span style="color:var(--gold); font-size:0.8rem;">üëë Leader</span>' : ''}</span>`;
                if (isLeader && !isLeaderMember) {
                    html += `<button class="action-btn" data-member="${safeMember}" onclick="window._kickMember(this.dataset.member)" style="font-size:0.75rem; padding:5px 10px; background:#3a0000;">Kick</button>`;
                }
                html += `</div>`;
            });
            html += '</div>';
            
            if (isLeader) {
                html += '<button class="action-btn" onclick="disbandGuild()" style="background:#8b0000;">Disband Guild</button>';
                html += '<button class="action-btn" onclick="declareWar()">Declare War</button>';
            }
            
            html += '<button class="action-btn" onclick="leaveGuild()">Leave Guild</button>';
            
            // Guild Chat
            html += '<div style="margin-top:30px; border-top:1px solid #222; padding-top:15px;">';
            html += '<h4 style="color:#4af;">Guild Chat</h4>';
            html += '<div id="guild-chat-log" style="height:200px; overflow-y:auto; border:1px solid #333; padding:10px; margin-bottom:10px; font-size:0.9rem;"></div>';
            html += '<div style="display:flex; gap:5px;">';
            html += '<input type="text" id="guild-chat-in" placeholder="Message your guild..." style="flex:1; width:auto;" onkeypress="if(event.key===\'Enter\')sendGuildChat()">';
            html += '<button class="action-btn" onclick="sendGuildChat()">Send</button>';
            html += '</div></div>';
            
            // Show other guilds (with search)
            let otherGuilds = Object.entries(gameState.guilds).filter(([id]) => id !== p.guild);
            if (guildSearchTerm) {
                otherGuilds = otherGuilds.filter(([id, g]) => g.name.toLowerCase().includes(guildSearchTerm) || g.tag.toLowerCase().includes(guildSearchTerm) || (g.blurb || '').toLowerCase().includes(guildSearchTerm));
            }
            if (otherGuilds.length > 0 || guildSearchTerm) {
                html += '<div style="margin-top:30px; border-top:1px solid #222; padding-top:15px;">';
                html += '<h4 style="color:#888;">Other Guilds</h4>';
                if (otherGuilds.length === 0) {
                    html += '<p style="color:#666;">No guilds match your search.</p>';
                }
                otherGuilds.forEach(([id, g]) => {
                    html += `<div style="border:1px solid #222; padding:10px; margin-bottom:5px;">`;
                    html += `<strong style="color:#4af;">„Äê${sanitize(g.tag)}„Äë${sanitize(g.name)}</strong> - ${g.members.length}/10 members`;
                    if (g.blurb) {
                        html += `<div style="color:#999; font-size:0.85rem; margin-top:4px; font-style:italic;">"${sanitize(g.blurb)}"</div>`;
                    }
                    html += `</div>`;
                });
                html += '</div>';
            }
            
            container.innerHTML = html;
            displayGuildChat();
        }
    }

    function showCreateGuild() {
        const rawName = prompt('Guild Name (2-30 chars, alphanumeric):');
        const name = validateGuildName(rawName);
        if (!name) {
            alert('Invalid guild name. Use 2-30 characters, alphanumeric/spaces/hyphens only.');
            return;
        }
        
        const rawTag = prompt('Guild Tag (3-5 characters, alphanumeric):');
        const tag = validateGuildTag(rawTag);
        if (!tag) {
            alert('Invalid tag. Must be 3-5 alphanumeric characters.');
            return;
        }
        
        if (p.gold < 500) {
            alert('You need 500 gold to create a guild.');
            return;
        }
        
        const guildId = 'guild_' + Date.now();
        gameState.guilds[guildId] = {
            name: name,
            tag: tag,
            leader: currentUser,
            members: [currentUser],
            blurb: '',
            createdAt: Date.now()
        };
        
        gameAction(() => {
        p.guild = guildId;
        p.gold -= 500;
        markDirty();
        });
        
        addLog(`<span style="color:#4af;">Guild „Äê${sanitize(tag)}„Äë${sanitize(name)} created!</span>`);
        sendSystemChat(`üè∞ ${currentUser} has founded the guild „Äê${sanitize(tag)}„Äë${sanitize(name)}!`);
        
        refreshUI();
        refreshGuildUI();
        markDirty(true);
    }

    function saveGuildBlurb() {
        if (!p.guild) return;
        const guild = gameState.guilds[p.guild];
        if (!guild || guild.leader !== currentUser) return;
        
        const input = document.getElementById('guild-blurb-input');
        if (!input) return;
        
        let blurb = input.value.trim();
        if (blurb.length > 150) {
            blurb = blurb.substring(0, 150);
        }
        // Strip any HTML from blurb
        const tempDiv = document.createElement('div');
        tempDiv.textContent = blurb;
        blurb = tempDiv.textContent;
        
        guild.blurb = blurb;
        markDirty();
        
        showToast('purchase', '‚úì Saved', 'Guild tagline updated', '');
        refreshGuildUI();
    }

    function joinGuild(guildId) {
        const guild = gameState.guilds[guildId];
        if (!guild) return;
        
        if (guild.members.includes(currentUser)) {
            alert('You are already in this guild.');
            return;
        }
        
        if (guild.members.length >= 10) {
            alert('This guild is full (10/10 members).');
            return;
        }
        
        guild.members.push(currentUser);
        p.guild = guildId;
        
        addLog(`<span style="color:#4af;">You joined „Äê${sanitize(guild.tag)}„Äë${sanitize(guild.name)}!</span>`);
        sendSystemChat(`üè∞ ${currentUser} has joined „Äê${sanitize(guild.tag)}„Äë${sanitize(guild.name)}!`);
        
        refreshUI();
        refreshGuildUI();
        markDirty();
    }

    function kickMember(memberName) {
        if (!p.guild) return;
        const guild = gameState.guilds[p.guild];
        if (!guild || guild.leader !== currentUser) return;
        if (memberName === currentUser) return;
        
        const memberData = gameState.players[memberName];
        const memberDisplay = sanitize(memberData?.displayName || memberName);
        
        if (!confirm(`Kick ${memberDisplay} from the guild?`)) return;
        
        guild.members = guild.members.filter(m => m !== memberName);
        if (gameState.players[memberName]) {
            gameState.players[memberName].guild = null;
        }
        
        addLog(`<span style="color:#ff4444;">You kicked ${memberDisplay} from the guild.</span>`);
        sendSystemChat(`üè∞ ${memberDisplay} has been kicked from „Äê${sanitize(guild.tag)}„Äë${sanitize(guild.name)}.`);
        
        refreshGuildUI();
        markDirty();
    }

    function leaveGuild() {
        const guild = gameState.guilds[p.guild];
        if (!guild) return;
        
        if (guild.leader === currentUser) {
            alert('You are the leader. Disband the guild or transfer leadership first.');
            return;
        }
        
        guild.members = guild.members.filter(m => m !== currentUser);
        p.guild = null;
        
        addLog('<span style="color:#888;">You left the guild.</span>');
        
        refreshUI();
        refreshGuildUI();
        markDirty();
    }

    function disbandGuild() {
        const guild = gameState.guilds[p.guild];
        if (!guild || guild.leader !== currentUser) return;
        
        if (!confirm(`Disband „Äê${guild.tag}„Äë${guild.name}? This cannot be undone.`)) {
            return;
        }
        
        guild.members.forEach(member => {
            if (gameState.players[member]) {
                gameState.players[member].guild = null;
            }
        });
        
        delete gameState.guilds[p.guild];
        p.guild = null;
        
        addLog('<span style="color:#ff4444;">Guild disbanded.</span>');
        sendSystemChat(`üèö The guild „Äê${guild.tag}„Äë${guild.name} has been disbanded!`);
        
        refreshUI();
        refreshGuildUI();
        markDirty();
    }

    function declareWar() {
        const guild = gameState.guilds[p.guild];
        if (!guild || guild.leader !== currentUser) return;
        
        // Find other guilds not already at war with us
        const otherGuilds = Object.entries(gameState.guilds)
            .filter(([id]) => id !== p.guild)
            .filter(([id]) => {
                // Check no active war between us and them
                return !gameState.wars.some(w => 
                    w.status === 'active' && 
                    ((w.attacker === p.guild && w.defender === id) || 
                     (w.attacker === id && w.defender === p.guild))
                );
            });
        
        if (otherGuilds.length === 0) {
            alert('No eligible guilds to declare war on.');
            return;
        }
        
        // Sort by similarity in member count (closest first)
        const mySize = guild.members.length;
        otherGuilds.sort((a, b) => {
            const diffA = Math.abs(a[1].members.length - mySize);
            const diffB = Math.abs(b[1].members.length - mySize);
            return diffA - diffB;
        });
        
        // Pick randomly from the closest-sized guilds (top 3 or all if fewer)
        const pool = otherGuilds.slice(0, Math.min(3, otherGuilds.length));
        const [targetId, targetGuild] = pool[Math.floor(Math.random() * pool.length)];
        
        if (!confirm(`Declare war on „Äê${targetGuild.tag}„Äë${targetGuild.name} (${targetGuild.members.length} members)?\n\nFirst to 20,000 frontier kills wins!`)) {
            return;
        }
        
        gameState.wars.push({
            attacker: p.guild,
            defender: targetId,
            attackerTag: guild.tag,
            defenderTag: targetGuild.tag,
            attackerName: guild.name,
            defenderName: targetGuild.name,
            attackerKills: 0,
            defenderKills: 0,
            status: 'active',
            startedAt: Date.now(),
            endedAt: null,
            winner: null
        });
        
        addLog(`<span style="color:#ff4444;">War declared against „Äê${sanitize(targetGuild.tag)}„Äë!</span>`);
        sendSystemChat(`‚öî WAR! „Äê${sanitize(guild.tag)}„Äë has declared war on „Äê${sanitize(targetGuild.tag)}„Äë! First to 20,000 frontier kills wins!`);
        
        markDirty();
    }

    function checkAndUpdateWarKills(guildId) {
        // Find active wars involving this guild
        gameState.wars.forEach(war => {
            if (war.status === 'active') {
                if (war.attacker === guildId) {
                    war.attackerKills++;
                    checkWarVictory(war);
                } else if (war.defender === guildId) {
                    war.defenderKills++;
                    checkWarVictory(war);
                }
            }
        });
        markDirty();
    }

    function checkWarVictory(war) {
        const VICTORY_KILLS = 20000;
        
        if (war.attackerKills >= VICTORY_KILLS) {
            endWar(war, war.attacker, 'attacker');
        } else if (war.defenderKills >= VICTORY_KILLS) {
            endWar(war, war.defender, 'defender');
        }
    }

    function endWar(war, winnerGuildId, winnerSide) {
        const REWARD_PER_PLAYER = 100000; // 10x reward overhaul
        
        war.status = 'ended';
        war.endedAt = Date.now();
        war.winner = winnerGuildId;
        
        const winnerGuild = gameState.guilds[winnerGuildId];
        const loserGuildId = winnerSide === 'attacker' ? war.defender : war.attacker;
        const loserGuild = gameState.guilds[loserGuildId];
        
        if (!winnerGuild || !loserGuild) return;
        
        // Award rewards to all members of winning guild
        let rewardedCount = 0;
        winnerGuild.members.forEach(memberName => {
            if (gameState.players[memberName]) {
                const member = gameState.players[memberName];
                member.gold += REWARD_PER_PLAYER;
                
                // Award Epic War Trophy (tracks total wins)
                if (!member.warTrophyWins) member.warTrophyWins = 0;
                member.warTrophyWins++;
                
                // Update or add the War Hero Trophy in trophies array
                if (!member.trophies) member.trophies = [];
                const existingWarTrophy = member.trophies.find(t => t.name === 'War Hero Trophy');
                if (existingWarTrophy) {
                    // Update existing trophy display ‚Äî no stat bonus
                    existingWarTrophy.count = member.warTrophyWins;
                } else {
                    member.trophies.push({
                        name: 'War Hero Trophy',
                        emoji: '‚öîÔ∏è',
                        rarity: 'epic',
                        str: 0,
                        wis: 0,
                        hp: 0,
                        fromBoss: 'guild_war',
                        earnedAt: Date.now(),
                        count: member.warTrophyWins
                    });
                }
                
                rewardedCount++;
            }
        });
        
        // Announce victory
        const finalScore = winnerSide === 'attacker' 
            ? `${war.attackerKills} - ${war.defenderKills}`
            : `${war.defenderKills} - ${war.attackerKills}`;
        
        sendSystemChat(`üèÜ WAR ENDED! „Äê${winnerGuild.tag}„Äë has defeated „Äê${loserGuild.tag}„Äë! Final Score: ${finalScore}. ${rewardedCount} warriors rewarded ${REWARD_PER_PLAYER.toLocaleString()} gold + ‚öîÔ∏è Epic War Trophy each!`);
        
        addLog(`<span style="color:var(--gold); font-weight:bold;">üèÜ Your guild has won the war! +${REWARD_PER_PLAYER.toLocaleString()} Gold + ‚öîÔ∏è War Hero Trophy!</span>`);
        
        markDirty();
        refreshUI();
    }

    function refreshWarsUI() {
        const activeList = document.getElementById('active-wars-list');
        const historyList = document.getElementById('war-history-list');
        
        if (!activeList || !historyList) return;
        
        // Active wars
        const activeWars = gameState.wars.filter(w => w.status === 'active');
        
        if (activeWars.length === 0) {
            activeList.innerHTML = '<p style="color:#666;">No active wars.</p>';
        } else {
            let html = '';
            activeWars.forEach(war => {
                const progress = Math.max(war.attackerKills, war.defenderKills) / 20000 * 100;
                const leading = war.attackerKills > war.defenderKills ? war.attackerTag : war.defenderTag;
                const leadingKills = Math.max(war.attackerKills, war.defenderKills);
                
                html += `<div style="border:1px solid #444; padding:15px; margin-bottom:15px; background:#0a0a0a;">`;
                html += `<h4 style="margin:0 0 10px 0; color:var(--accent);">„Äê${war.attackerTag}„Äë vs „Äê${war.defenderTag}„Äë</h4>`;
                html += `<div style="display:flex; justify-content:space-between; margin-bottom:8px;">`;
                html += `<span style="color:#4af;">„Äê${war.attackerTag}„Äë: ${war.attackerKills.toLocaleString()} kills</span>`;
                html += `<span style="color:#f4a;">„Äê${war.defenderTag}„Äë: ${war.defenderKills.toLocaleString()} kills</span>`;
                html += `</div>`;
                html += `<div style="background:#222; height:20px; border:1px solid #444; position:relative; overflow:hidden;">`;
                html += `<div style="background:linear-gradient(90deg, var(--accent), #ff4444); height:100%; width:${progress}%; transition:width 0.3s;"></div>`;
                html += `</div>`;
                html += `<p style="margin:8px 0 0 0; color:#888; font-size:0.85rem;">„Äê${leading}„Äë leading ‚Ä¢ ${(20000 - leadingKills).toLocaleString()} kills to victory</p>`;
                html += `</div>`;
            });
            activeList.innerHTML = html;
        }
        
        // War history
        const endedWars = gameState.wars.filter(w => w.status === 'ended').slice(-10).reverse();
        
        if (endedWars.length === 0) {
            historyList.innerHTML = '<p style="color:#666;">No war history yet.</p>';
        } else {
            let html = '<div style="font-family:monospace; font-size:0.85rem;">';
            endedWars.forEach(war => {
                const winnerGuild = gameState.guilds[war.winner];
                const winnerTag = winnerGuild ? winnerGuild.tag : '???';
                const loserTag = war.winner === war.attacker ? war.defenderTag : war.attackerTag;
                const duration = Math.floor((war.endedAt - war.startedAt) / 1000 / 60); // minutes
                const endDate = new Date(war.endedAt).toLocaleDateString();
                
                html += `<div style="border-bottom:1px solid #222; padding:10px 0;">`;
                html += `<span style="color:var(--gold);">üèÜ „Äê${winnerTag}„Äë</span> defeated `;
                html += `<span style="color:#666;">„Äê${loserTag}„Äë</span> `;
                html += `<span style="color:#888;">(${war.attackerKills.toLocaleString()} - ${war.defenderKills.toLocaleString()}) ‚Ä¢ ${endDate}</span>`;
                html += `</div>`;
            });
            html += '</div>';
            historyList.innerHTML = html;
        }
    }

    // ============================================
    // CHAT SYSTEM
    // ============================================
    function sendChatMsg() {
        if (rateLimited('chat', 1000)) {
            showToast('error', 'Slow down', 'Please wait before sending another message', '');
            return;
        }
        const input = document.getElementById('chat-in');
        const msg = validateChatMessage(input.value);
        if (!msg) return;
        
        const chatMsg = {
            id: Date.now() + '-' + currentUser,
            user: currentUser,
            text: msg,
            time: Date.now()
        };
        
        gameState.chat.push(chatMsg);
        seenChatIds.add(chatMsg.id);
        
        if (gameState.chat.length > 100) {
            gameState.chat.shift();
        }
        
        displayChat();
        input.value = '';
        markDirty();
    }

    function sendSystemChat(text) {
        const chatMsg = {
            id: Date.now() + '-system',
            user: 'SYSTEM',
            text: text,
            time: Date.now()
        };
        
        gameState.chat.push(chatMsg);
        seenChatIds.add(chatMsg.id);
        
        if (gameState.chat.length > 100) {
            gameState.chat.shift();
        }
        
        displayChat();
        markDirty();
    }

    function displayChat() {
        const log = document.getElementById('chat-log');
        if (!log) return;
        
        log.innerHTML = '';
        gameState.chat.slice(-50).forEach(msg => {
            // Filter: only show player messages, war declarations, and news
            if (msg.user === 'SYSTEM') {
                const text = msg.text;
                // Allow: war declarations, war endings, news, boss kills, guild founding/disbanding, void gate
                const isWar = text.includes('WAR') || text.includes('‚öî WAR');
                const isNews = text.includes('üì∞');
                const isBoss = text.includes('slain the Void Titan');
                const isGuildEvent = text.includes('founded the guild') || text.includes('has been disbanded');
                const isBackup = text.includes('backup');
                
                // Skip: logins ("entered the Void"), arena attacks ("defeated X in the Arena"), guild joins
                const isLogin = text.includes('has entered the Void');
                const isArenaAttack = text.includes('in the Arena');
                const isGuildJoin = text.includes('has joined');
                
                if (isLogin || isArenaAttack || isGuildJoin) return;
                if (!(isWar || isNews || isBoss || isGuildEvent || isBackup)) return;
            }
            
            const div = document.createElement('div');
            div.style.marginBottom = '5px';
            
            if (msg.user === 'SYSTEM') {
                div.style.color = '#888';
                div.innerHTML = `<strong>[SYSTEM]</strong> ${sanitize(msg.text)}`;
            } else {
                const userColor = msg.user === currentUser ? 'var(--gold)' : '#4af';
                const playerData = gameState.players[msg.user];
                const displayName = playerData?.displayName || msg.user;
                div.innerHTML = `<strong style="color:${userColor};">${sanitize(displayName)}:</strong> ${sanitize(msg.text)}`;
            }
            
            log.appendChild(div);
        });
        
        log.scrollTop = log.scrollHeight;
    }

    // ============================================
    // NEWS
    // ============================================
    function refreshNews() {
        const container = document.getElementById('news-list');
        if (!container) return;
        
        // Show/hide admin post UI
        const adminUI = document.getElementById('admin-news-post');
        if (adminUI) {
            if (currentUser === ADMIN) {
                adminUI.classList.remove('hidden');
            } else {
                adminUI.classList.add('hidden');
            }
        }
        
        if (gameState.news.length === 0) {
            container.innerHTML = '<p style="color:#666;">No news yet.</p>';
            return;
        }
        
        let html = '';
        gameState.news.slice().reverse().slice(0, 20).forEach(item => {
            const date = new Date(item.time).toLocaleString();
            html += `<div style="border-bottom:1px solid #222; padding:10px 0;">`;
            html += `<div style="color:#888; font-size:0.8rem; margin-bottom:5px;">${sanitize(date)}</div>`;
            html += `<div>${sanitize(item.text)}</div>`;
            html += `</div>`;
        });
        
        container.innerHTML = html;
    }

    function addNews(text) {
        gameState.news.push({
            text: text,
            time: Date.now()
        });
        
        if (gameState.news.length > 100) {
            gameState.news.shift();
        }
        
        markDirty();
    }

    function postNews() {
        if (currentUser !== ADMIN) {
            alert('Only the Void Master can post news.');
            return;
        }
        
        const input = document.getElementById('news-input');
        const text = input.value.trim();
        
        if (!text) {
            alert('Please enter a news message.');
            return;
        }
        
        addNews(text);
        sendSystemChat(`üì∞ ${text}`);
        input.value = '';
        refreshNews();
        
        addLog("<span style='color:var(--admin)'>News posted to realm.</span>");
    }

    // ============================================
    // PROFILE SYSTEM
    // ============================================
    function saveProfile() {
        const rawDisplayName = document.getElementById('profile-displayname').value.trim();
        const avatar = document.getElementById('profile-avatar').value;
        const rawBio = document.getElementById('profile-bio').value.trim();
        const status = document.getElementById('profile-status');
        
        if (rawDisplayName) {
            const validated = validateDisplayName(rawDisplayName);
            if (!validated) {
                status.style.color = '#ff4444';
                status.innerText = 'Display name must be 2-20 characters, alphanumeric/spaces/hyphens only.';
                return;
            }
        }
        
        if (rawBio) {
            const validated = validateBio(rawBio);
            if (!validated) {
                status.style.color = '#ff4444';
                status.innerText = 'Bio must be 200 characters or less.';
                return;
            }
        }
        
        // Save display name
        if (rawDisplayName) {
            p.displayName = validateDisplayName(rawDisplayName);
        } else {
            delete p.displayName;
        }
        
        // Save avatar (only allow known emojis)
        const allowedAvatars = ['‚öîÔ∏è','üó°Ô∏è','üõ°Ô∏è','üë§','ü¶á','üíÄ','üëª','üêç','üî•','‚ùÑÔ∏è','‚ö°','üåô','üêâ','ü¶Ö','üê∫','ü¶Å'];
        p.avatar = allowedAvatars.includes(avatar) ? avatar : '‚öîÔ∏è';
        
        // Save bio
        if (rawBio) {
            p.bio = validateBio(rawBio);
        } else {
            delete p.bio;
        }
        
        markDirty();
        
        status.style.color = '#44ff44';
        status.innerText = '‚úì Profile saved!';
        
        setTimeout(() => {
            status.innerText = '';
        }, 3000);
        
        refreshUI();
        addLog('<span style="color:var(--gold)">Profile updated.</span>');
    }

    function selectAvatar(emoji) {
        // Check if avatar is locked
        const avatarTiers = [
            { level: 1, emojis: ['‚öîÔ∏è','üó°Ô∏è','üõ°Ô∏è','üë§'] },
            { level: 10, emojis: ['ü¶á','üíÄ','üëª','üêç'] },
            { level: 25, emojis: ['üî•','‚ùÑÔ∏è','‚ö°','üåô'] },
            { level: 50, emojis: ['üêâ','ü¶Ö','üê∫','ü¶Å'] }
        ];
        for (const tier of avatarTiers) {
            if (tier.emojis.includes(emoji) && p.level < tier.level) {
                showToast('error', 'üîí Locked', `Requires Level ${tier.level}`, `You are Level ${p.level}`);
                return;
            }
        }
        document.getElementById('profile-avatar').value = emoji;
        
        // Update visual selection
        document.querySelectorAll('.avatar-option').forEach(opt => {
            opt.classList.remove('selected');
        });
        const sel = document.querySelector(`.avatar-option[data-avatar="${emoji}"]`);
        if (sel) sel.classList.add('selected');
    }

    function renderAvatarSelector() {
        const container = document.getElementById('avatar-selector');
        if (!container) return;
        const avatarTiers = [
            { level: 1, emojis: ['‚öîÔ∏è','üó°Ô∏è','üõ°Ô∏è','üë§'] },
            { level: 10, emojis: ['ü¶á','üíÄ','üëª','üêç'] },
            { level: 25, emojis: ['üî•','‚ùÑÔ∏è','‚ö°','üåô'] },
            { level: 50, emojis: ['üêâ','ü¶Ö','üê∫','ü¶Å'] }
        ];
        const currentAvatar = p.avatar || '‚öîÔ∏è';
        let html = '';
        avatarTiers.forEach(tier => {
            tier.emojis.forEach(em => {
                const locked = p.level < tier.level;
                const selected = em === currentAvatar;
                html += `<div class="avatar-option${locked ? ' avatar-locked' : ''}${selected ? ' selected' : ''}" data-avatar="${em}" onclick="selectAvatar('${em}')">`;
                html += em;
                if (locked) html += `<span class="avatar-lock-tooltip">Lv ${tier.level} Required</span>`;
                html += `</div>`;
            });
        });
        container.innerHTML = html;
    }

    // ============================================
    // GUILD CHAT
    // ============================================
    function sendGuildChat() {
        if (!p.guild) return;
        const guild = gameState.guilds[p.guild];
        if (!guild) return;
        
        if (rateLimited('guildchat', 1000)) {
            showToast('error', 'Slow down', 'Please wait before sending another message', '');
            return;
        }
        
        const input = document.getElementById('guild-chat-in');
        const msg = validateChatMessage(input.value);
        if (!msg) return;
        
        if (!guild.chat) guild.chat = [];
        
        guild.chat.push({
            user: currentUser,
            text: msg,
            time: Date.now()
        });
        
        // Keep last 100 messages
        if (guild.chat.length > 100) guild.chat.shift();
        
        input.value = '';
        displayGuildChat();
        markDirty();
    }
    
    function displayGuildChat() {
        const log = document.getElementById('guild-chat-log');
        if (!log || !p.guild) return;
        
        const guild = gameState.guilds[p.guild];
        if (!guild) return;
        
        const messages = guild.chat || [];
        log.innerHTML = '';
        
        messages.slice(-50).forEach(msg => {
            const div = document.createElement('div');
            div.style.marginBottom = '5px';
            const userColor = msg.user === currentUser ? 'var(--gold)' : '#4af';
            const playerData = gameState.players[msg.user];
            const displayName = playerData?.displayName || msg.user;
            div.innerHTML = `<strong style="color:${userColor};">${sanitize(displayName)}:</strong> ${sanitize(msg.text)}`;
            log.appendChild(div);
        });
        
        log.scrollTop = log.scrollHeight;
    }

    // ============================================
    // ADMIN CONSOLE (Replaces Backup)
    // ============================================
    function refreshAdminConsole() {
        if (currentUser !== ADMIN) return;
        
        const info = document.getElementById('admin-info');
        if (info) {
            const playerCount = Object.keys(gameState.players).length;
            const accountCount = Object.keys(getAccounts()).length;
            const guildCount = Object.keys(gameState.guilds || {}).length;
            const warCount = (gameState.wars || []).length;
            const newsCount = (gameState.news || []).length;
            const chatCount = (gameState.chat || []).length;
            const bannedCount = Object.values(gameState.players).filter(pl => pl.banned).length;
            
            info.innerHTML = `Players: ${playerCount} ¬∑ Accounts: ${accountCount} ¬∑ Guilds: ${guildCount}<br>` +
                `Wars: ${warCount} ¬∑ News: ${newsCount} ¬∑ Chat msgs: ${chatCount}<br>` +
                `Banned: ${bannedCount}`;
        }
        
        refreshAdminPlayerList();
    }
    
    function refreshAdminPlayerList() {
        if (currentUser !== ADMIN) return;
        const container = document.getElementById('admin-player-list');
        if (!container) return;
        
        const searchTerm = (document.getElementById('admin-player-search')?.value || '').trim().toLowerCase();
        
        let players = Object.entries(gameState.players);
        if (searchTerm) {
            players = players.filter(([name, data]) => {
                const displayName = (data.displayName || name).toLowerCase();
                return name.toLowerCase().includes(searchTerm) || displayName.includes(searchTerm);
            });
        }
        
        players.sort((a, b) => b[1].level - a[1].level);
        
        if (players.length === 0) {
            container.innerHTML = '<p style="color:#666;">No players found.</p>';
            return;
        }
        
        let html = '';
        players.forEach(([name, data]) => {
            const displayName = sanitize(data.displayName || name);
            const avatar = data.avatar || '‚öîÔ∏è';
            const isBanned = data.banned;
            const isAdmin = name === ADMIN;
            const safeName = safeAttr(name);
            
            html += `<div style="display:flex; justify-content:space-between; align-items:center; padding:8px 10px; border-bottom:1px solid #222;${isBanned ? ' opacity:0.5; background:#1a0000;' : ''}">`;
            html += `<span>${avatar} <span class="name-link" data-player="${safeName}" onclick="window._showPlayer(this.dataset.player)">${displayName}</span> <span style="color:#666; font-size:0.8rem;">(${sanitize(name)}) Lv${data.level} ‚öú${data.gold || 0}</span>`;
            if (isBanned) html += ` <span style="color:#ff4444; font-size:0.75rem;">BANNED</span>`;
            html += `</span>`;
            
            if (!isAdmin) {
                html += `<span style="display:flex; gap:4px;">`;
                if (isBanned) {
                    html += `<button class="action-btn" data-player="${safeName}" onclick="window._adminUnban(this.dataset.player)" style="font-size:0.7rem; padding:4px 8px; background:#1a3a1a;">Unban</button>`;
                } else {
                    html += `<button class="action-btn" data-player="${safeName}" onclick="window._adminBan(this.dataset.player)" style="font-size:0.7rem; padding:4px 8px; background:#3a3a00;">Ban</button>`;
                }
                html += `<button class="action-btn" data-player="${safeName}" onclick="window._adminDelete(this.dataset.player)" style="font-size:0.7rem; padding:4px 8px; background:#3a0000;">Delete</button>`;
                html += `</span>`;
            }
            html += `</div>`;
        });
        
        container.innerHTML = html;
    }
    
    function adminBanPlayer(username) {
        if (currentUser !== ADMIN || username === ADMIN) return;
        if (!confirm(`Ban ${username}? They will not be able to log in.`)) return;
        
        if (gameState.players[username]) {
            gameState.players[username].banned = true;
            gameState.players[username].online = false;
        }
        
        markDirty();
        refreshAdminConsole();
        showToast('error', 'üö´ Banned', username, '');
        sendSystemChat(`üö´ ${username} has been banished from the realm.`);
    }
    
    function adminUnbanPlayer(username) {
        if (currentUser !== ADMIN) return;
        if (gameState.players[username]) {
            delete gameState.players[username].banned;
        }
        markDirty();
        refreshAdminConsole();
        showToast('purchase', '‚úì Unbanned', username, '');
    }
    
    function adminDeletePlayer(username) {
        if (currentUser !== ADMIN || username === ADMIN) return;
        if (!confirm(`Permanently delete ${username}? This removes their player data AND account.`)) return;
        if (!confirm(`Are you SURE? This cannot be undone.`)) return;
        
        // Remove from guild
        const playerGuild = gameState.players[username]?.guild;
        if (playerGuild && gameState.guilds[playerGuild]) {
            const guild = gameState.guilds[playerGuild];
            guild.members = guild.members.filter(m => m !== username);
            if (guild.leader === username) {
                if (guild.members.length > 0) {
                    guild.leader = guild.members[0];
                } else {
                    delete gameState.guilds[playerGuild];
                }
            }
        }
        
        // Remove player data
        delete gameState.players[username];
        
        // Remove account
        const accounts = getAccounts();
        delete accounts[username];
        saveAccounts(accounts);
        
        markDirty();
        refreshAdminConsole();
        showToast('error', 'üóë Deleted', username, 'Account and data removed');
        addLog(`<span style='color:var(--admin)'>Deleted player: ${sanitize(username)}</span>`);
    }
    
    function adminResetStats() {
        if (currentUser !== ADMIN) return;
        if (!confirm('Reset ALL player stats? This keeps accounts but resets levels, gold, kills, etc. to fresh.')) return;
        if (!confirm('This will reset EVERY player. Are you sure?')) return;
        
        Object.keys(gameState.players).forEach(name => {
            const pl = gameState.players[name];
            const accounts = getAccounts();
            const race = accounts[name]?.race || pl.race || 'Hollow';
            
            gameState.players[name] = {
                race: race,
                level: 1,
                xp: 0,
                hp: 100,
                maxHp: 100,
                str: race === 'Hollow' ? 11 : 10,
                wis: race === 'Wraith' ? 11 : 10,
                gold: 0,
                guild: null,
                kills: 0,
                deaths: 0,
                online: pl.online,
                lastSeen: pl.lastSeen,
                createdAt: Date.now(),
                displayName: pl.displayName,
                avatar: pl.avatar,
                bio: pl.bio,
                bossData: {},
                trophies: [],
                voidEntityTier: 0,
                dailyQuests: null,
                dailyQuestsLastReset: 0,
                warTrophyWins: 0,
                totalGoldSpent: 0,
                totalBossKills: 0
            };
        });
        
        // Clear guilds and wars
        gameState.guilds = {};
        gameState.wars = [];
        
        // Reset current player ref
        p = gameState.players[currentUser];
        _stampIntegrity();
        refreshUI();
        markDirty();
        refreshAdminConsole();
        
        showToast('purchase', 'üîÑ Stats Reset', 'All player stats reset to fresh', '');
        sendSystemChat('üîÑ The Void Master has reset all player stats!');
    }
    
    function adminFullReset() {
        if (currentUser !== ADMIN) return;
        if (!confirm('‚ö† FULL SERVER RESET ‚ö†\n\nThis will delete ALL data: players, guilds, wars, chat, news.\nOnly accounts will be preserved.\n\nAre you absolutely sure?')) return;
        if (!confirm('LAST CHANCE: This cannot be undone. Proceed?')) return;
        
        gameState.players = {};
        gameState.guilds = {};
        gameState.wars = [];
        gameState.news = [];
        gameState.chat = [];
        gameState.gate = 'CLOSED';
        
        // Recreate admin player
        const accounts = getAccounts();
        const adminRace = accounts[ADMIN]?.race || 'Hollow';
        gameState.players[ADMIN] = {
            race: adminRace,
            level: 1, xp: 0, hp: 100, maxHp: 100,
            str: adminRace === 'Hollow' ? 11 : 10,
            wis: adminRace === 'Wraith' ? 11 : 10,
            gold: 0, guild: null, kills: 0, deaths: 0,
            online: true, lastSeen: Date.now(), createdAt: Date.now(),
            bossData: {}, trophies: [],
            voidEntityTier: 0, dailyQuests: null, dailyQuestsLastReset: 0,
            warTrophyWins: 0, totalGoldSpent: 0, totalBossKills: 0
        };
        
        p = gameState.players[ADMIN];
        _stampIntegrity();
        refreshUI();
        markDirty();
        refreshAdminConsole();
        
        showToast('error', 'üí£ Full Reset', 'Server data wiped', '');
        addLog("<span style='color:var(--admin)'>Full server reset completed.</span>");
    }
    
    function adminClearChat() {
        if (currentUser !== ADMIN) return;
        if (!confirm('Clear all tavern chat messages?')) return;
        gameState.chat = [];
        markDirty();
        showToast('purchase', '‚úì Chat Cleared', '', '');
    }
    
    function adminClearNews() {
        if (currentUser !== ADMIN) return;
        if (!confirm('Clear all news?')) return;
        gameState.news = [];
        markDirty();
        showToast('purchase', '‚úì News Cleared', '', '');
    }
    
    function adminClearWars() {
        if (currentUser !== ADMIN) return;
        if (!confirm('Clear all war history? Active wars will also be removed.')) return;
        gameState.wars = [];
        markDirty();
        showToast('purchase', '‚úì Wars Cleared', '', '');
    }
    
    function adminGiveGold() {
        if (currentUser !== ADMIN) return;
        const target = prompt('Username to give gold to:');
        if (!target || !isValidUsername(target) || !gameState.players[target]) {
            alert('Player not found or invalid username.');
            return;
        }
        const amount = parseInt(prompt('Amount of gold:'));
        if (isNaN(amount) || amount <= 0) {
            alert('Invalid amount.');
            return;
        }
        gameState.players[target].gold += amount;
        if (target === currentUser) _stampIntegrity();
        markDirty();
        refreshAdminConsole();
        showToast('purchase', 'üí∞ Gold Given', `${amount} gold to ${target}`, '');
        addLog(`<span style='color:var(--admin)'>Gave ${amount} gold to ${sanitize(target)}</span>`);
    }

    // ============================================
    // BACKUP FUNCTIONS (used by admin console)
    // ============================================
    function downloadBackup() {
        if (currentUser !== ADMIN) return;

        const backup = {
            _meta: {
                version: 1,
                exported: new Date().toISOString(),
                exportedBy: currentUser,
                realm: document.getElementById('realm-name').value.trim() || 'void-realm-default'
            },
            accounts: getAccounts(),
            gameState: {
                players: gameState.players,
                guilds: gameState.guilds || {},
                wars: gameState.wars || [],
                news: gameState.news || [],
                gate: gameState.gate || 'CLOSED',
                chat: gameState.chat || []
            }
        };

        const json = JSON.stringify(backup, null, 2);
        const blob = new Blob([json], { type: 'application/json' });
        const url = URL.createObjectURL(blob);
        
        const a = document.createElement('a');
        const dateStr = new Date().toISOString().replace(/[:.]/g, '-').slice(0, 19);
        a.href = url;
        a.download = `void-slayer-backup-${dateStr}.json`;
        document.body.appendChild(a);
        a.click();
        document.body.removeChild(a);
        URL.revokeObjectURL(url);

        const status = document.getElementById('backup-status');
        status.style.color = '#44ff44';
        status.innerText = '‚úÖ Backup downloaded!';
        addLog("<span style='color:var(--admin)'>Realm backup downloaded.</span>");
    }

    function uploadBackup(event) {
        if (currentUser !== ADMIN) return;
        const status = document.getElementById('backup-status');
        
        const file = event.target.files[0];
        if (!file) return;

        const reader = new FileReader();
        reader.onload = function(e) {
            try {
                const backup = JSON.parse(e.target.result);
                
                if (!backup.gameState || !backup.accounts) {
                    status.style.color = '#ff4444';
                    status.innerText = '‚ùå Invalid backup file ‚Äî missing gameState or accounts.';
                    return;
                }

                const gs = backup.gameState;
                const playerCount = Object.keys(gs.players || {}).length;
                const accountCount = Object.keys(backup.accounts || {}).length;
                const meta = backup._meta || {};

                if (!confirm(
                    `Restore this backup?\n\n` +
                    `From: ${meta.exported || 'Unknown date'}\n` +
                    `Realm: ${meta.realm || 'Unknown'}\n` +
                    `Players: ${playerCount}\n` +
                    `Accounts: ${accountCount}\n\n` +
                    `This will OVERWRITE all current realm data.`
                )) {
                    status.style.color = '#888';
                    status.innerText = 'Restore cancelled.';
                    return;
                }

                // Restore accounts
                const accounts = backup.accounts;
                saveAccounts(accounts);

                // Restore game state
                if (gs.players) gameState.players = gs.players;
                if (gs.guilds) gameState.guilds = gs.guilds;
                if (gs.wars) gameState.wars = gs.wars;
                if (gs.news) gameState.news = gs.news;
                if (gs.gate) gameState.gate = gs.gate;
                if (gs.chat) {
                    gameState.chat = gs.chat;
                    gs.chat.forEach(msg => seenChatIds.add(msg.id));
                }

                // Reload own player data if present
                if (gameState.players[currentUser]) {
                    Object.assign(p, gameState.players[currentUser]);
                    _stampIntegrity();
                    refreshUI();
                }

                // Force cloud sync
                saveToCloud(true);
                
                updatePlayerCount();

                status.style.color = '#44ff44';
                status.innerText = `‚úÖ Restored! ${playerCount} players, ${accountCount} accounts loaded.`;
                addLog("<span style='color:var(--admin)'>Realm backup restored!</span>");
                sendSystemChat("üîÑ The Void Master has restored the realm from a backup!");

                refreshAdminConsole();
            } catch (err) {
                status.style.color = '#ff4444';
                status.innerText = '‚ùå Error reading backup: ' + err.message;
            }
        };
        reader.readAsText(file);
        
        event.target.value = '';
    }

    // ============================================
    // STAT INTEGRITY / ANTI-CHEAT SYSTEM
    // ============================================
    // Uses closure-based integrity checking that cannot be accessed from console.
    // All stat mutations must go through gameAction() wrapper.
    // IIFE encapsulation prevents external access to _stampIntegrity/_revertStats.

    // Cryptographically stronger seed (not easily reversed)
    const _SEED = (function() {
        const a = [86,48,73,68,83,76,65,89,51,82];
        let s = '';
        for (let i = 0; i < a.length; i++) s += String.fromCharCode(a[i] ^ ((i * 7 + 13) & 0xFF));
        return s + '_' + (new Date(2024,0,1).getTime());
    })();
    let _lastGoodSnap = null;
    let _actionActive = false;
    let _integrityCounter = 0; // Monotonic counter prevents replay

    function _fnv1a(str) {
        let h = 0x811c9dc5;
        for (let i = 0; i < str.length; i++) {
            h ^= str.charCodeAt(i);
            h = Math.imul(h, 0x01000193);
        }
        return (h >>> 0).toString(36);
    }

    function _signStats(pl) {
        if (!pl) return '';
        // Include more fields and counter to prevent simple replay
        const raw = `${pl.level}|${pl.xp}|${pl.hp}|${pl.maxHp}|${pl.str}|${pl.wis}|${pl.gold}|${pl.kills}|${pl.deaths}|${_integrityCounter}|${_SEED}`;
        return _fnv1a(raw);
    }

    function _snapStats(pl) {
        if (!pl) return null;
        return { level:pl.level, xp:pl.xp, hp:pl.hp, maxHp:pl.maxHp, str:pl.str, wis:pl.wis, gold:pl.gold, kills:pl.kills, deaths:pl.deaths };
    }

    function _stampIntegrity() {
        if (!p) return;
        _integrityCounter++;
        p._sig = _signStats(p);
        p._sc = _integrityCounter; // Store counter with signature
        _lastGoodSnap = _snapStats(p);
    }

    function _verifyIntegrity() {
        if (!p || !p._sig || !_lastGoodSnap) return true;
        // Restore counter for verification
        const savedCounter = _integrityCounter;
        _integrityCounter = p._sc || _integrityCounter;
        const result = _signStats(p) === p._sig;
        _integrityCounter = savedCounter;
        return result;
    }

    function _revertStats() {
        if (!_lastGoodSnap || !p) return;
        Object.assign(p, _lastGoodSnap);
        p._sig = _signStats(p);
        p._sc = _integrityCounter;
        refreshUI();
        addLog("<span style='color:#ff4444;'>‚ö† Stat tampering detected ‚Äî stats reverted.</span>");
        showToast('error', '‚ö† Integrity Violation', 'Stat modification detected', 'Stats have been reverted');
    }

    // Wrap every game action that legitimately changes stats
    function gameAction(fn) {
        _actionActive = true;
        try {
            fn();
        } finally {
            _actionActive = false;
            _stampIntegrity();
        }
    }

    // Periodic integrity check (every 3 seconds - more frequent)
    setInterval(() => {
        if (currentUser && p && p._sig) {
            if (!_verifyIntegrity()) {
                _revertStats();
            }
        }
    }, 3000);

    // Additional: Detect if gameState or p has been replaced entirely
    let _lastPlayerRef = null;
    setInterval(() => {
        if (currentUser && _lastPlayerRef && p !== _lastPlayerRef) {
            // Player reference changed outside of game code
            p = gameState.players[currentUser];
            _lastPlayerRef = p;
            if (p && _lastGoodSnap) {
                Object.assign(p, _lastGoodSnap);
                _stampIntegrity();
            }
        }
        _lastPlayerRef = p;
    }, 2000);

    // ============================================
    // BOSS SYSTEM
    // ============================================
    const BOSS_DEFINITIONS = [
        {
            id: 'shade_colossus', name: 'Shade Colossus', emoji: '', image: 'https://i.imgur.com/qU33C36.png', tier: 1, unlockLevel: 10,
            desc: 'A towering mass of condensed shadow, born from a thousand lost souls.',
            rewardType: 'xp', baseHp: 500, baseDamage: 15, hpPerLevel: 60, dmgPerLevel: 1.5,
            xpReward: 800, goldReward: 0, regenPerMin: 25,
            lootTable: [
                { name: 'Shadow Shard', emoji: 'üîÆ', rarity: 'common', str: 3, wis: 0, hp: 0, weight: 50 },
                { name: 'Colossus Fragment', emoji: 'üíé', rarity: 'uncommon', str: 5, wis: 2, hp: 10, weight: 30 },
                { name: 'Heart of the Colossus', emoji: '‚ù§Ô∏è‚Äçüî•', rarity: 'rare', str: 10, wis: 5, hp: 25, weight: 15 },
                { name: 'Shade Crown', emoji: 'üëë', rarity: 'epic', str: 15, wis: 10, hp: 50, weight: 4 },
                { name: 'Colossus Soul', emoji: '‚ú®', rarity: 'legendary', str: 25, wis: 15, hp: 80, weight: 1 }
            ]
        },
        {
            id: 'gold_wyrm', name: 'Gold Wyrm', emoji: '', image: 'https://i.imgur.com/HhpmUBd.png', tier: 2, unlockLevel: 20,
            desc: 'An ancient dragon that sleeps atop mountains of stolen gold.',
            rewardType: 'gold', baseHp: 1200, baseDamage: 22, hpPerLevel: 80, dmgPerLevel: 1.8,
            xpReward: 0, goldReward: 2000, regenPerMin: 40,
            lootTable: [
                { name: 'Wyrm Scale', emoji: 'üõ°Ô∏è', rarity: 'common', str: 0, wis: 3, hp: 10, weight: 50 },
                { name: 'Golden Fang', emoji: 'ü¶∑', rarity: 'uncommon', str: 4, wis: 4, hp: 15, weight: 30 },
                { name: 'Dragonheart Gem', emoji: 'üí†', rarity: 'rare', str: 8, wis: 8, hp: 30, weight: 15 },
                { name: 'Wyrm\'s Hoard Ring', emoji: 'üíç', rarity: 'epic', str: 12, wis: 12, hp: 60, weight: 4 },
                { name: 'Gold Wyrm Essence', emoji: 'üåü', rarity: 'legendary', str: 20, wis: 20, hp: 100, weight: 1 }
            ]
        },
        {
            id: 'void_sentinel', name: 'Void Sentinel', emoji: 'üóø', tier: 3, unlockLevel: 30,
            desc: 'An eternal guardian of the void gates, unyielding and relentless.',
            rewardType: 'xp', baseHp: 2200, baseDamage: 30, hpPerLevel: 100, dmgPerLevel: 2.0,
            xpReward: 2500, goldReward: 0, regenPerMin: 55,
            lootTable: [
                { name: 'Sentinel Stone', emoji: 'ü™®', rarity: 'common', str: 4, wis: 2, hp: 15, weight: 50 },
                { name: 'Void-Touched Shield', emoji: 'üõ°Ô∏è', rarity: 'uncommon', str: 3, wis: 6, hp: 25, weight: 30 },
                { name: 'Sentinel\'s Eye', emoji: 'üëÅÔ∏è', rarity: 'rare', str: 10, wis: 10, hp: 40, weight: 15 },
                { name: 'Gatekeeper\'s Mantle', emoji: 'üß•', rarity: 'epic', str: 15, wis: 15, hp: 70, weight: 4 },
                { name: 'Sentinel Core', emoji: '‚öõÔ∏è', rarity: 'legendary', str: 25, wis: 25, hp: 120, weight: 1 }
            ]
        },
        {
            id: 'abyssal_leviathan', name: 'Abyssal Leviathan', emoji: 'üêô', tier: 4, unlockLevel: 40,
            desc: 'A nightmare from the deepest trenches of the void ocean.',
            rewardType: 'gold', baseHp: 3500, baseDamage: 38, hpPerLevel: 120, dmgPerLevel: 2.2,
            xpReward: 0, goldReward: 5000, regenPerMin: 70,
            lootTable: [
                { name: 'Leviathan Ink', emoji: 'üñ§', rarity: 'common', str: 2, wis: 5, hp: 20, weight: 50 },
                { name: 'Abyssal Tentacle', emoji: 'ü¶ë', rarity: 'uncommon', str: 6, wis: 6, hp: 30, weight: 30 },
                { name: 'Deep Trident', emoji: 'üî±', rarity: 'rare', str: 14, wis: 8, hp: 50, weight: 15 },
                { name: 'Leviathan\'s Maw', emoji: 'üåÄ', rarity: 'epic', str: 18, wis: 18, hp: 80, weight: 4 },
                { name: 'Heart of the Abyss', emoji: 'üíú', rarity: 'legendary', str: 30, wis: 25, hp: 150, weight: 1 }
            ]
        },
        {
            id: 'eclipse_titan', name: 'Eclipse Titan', emoji: 'üåë', tier: 5, unlockLevel: 50,
            desc: 'Born when the void eclipsed the last sun, its power is absolute.',
            rewardType: 'xp', baseHp: 5000, baseDamage: 48, hpPerLevel: 150, dmgPerLevel: 2.5,
            xpReward: 6000, goldReward: 0, regenPerMin: 90,
            lootTable: [
                { name: 'Eclipse Shard', emoji: 'üåò', rarity: 'common', str: 5, wis: 5, hp: 25, weight: 50 },
                { name: 'Solar Remnant', emoji: '‚òÄÔ∏è', rarity: 'uncommon', str: 8, wis: 8, hp: 35, weight: 30 },
                { name: 'Titan\'s Gauntlet', emoji: 'üß§', rarity: 'rare', str: 18, wis: 10, hp: 60, weight: 15 },
                { name: 'Eclipse Diadem', emoji: 'üëë', rarity: 'epic', str: 22, wis: 22, hp: 100, weight: 4 },
                { name: 'Titan\'s Eclipse', emoji: 'üí´', rarity: 'legendary', str: 35, wis: 30, hp: 180, weight: 1 }
            ]
        },
        {
            id: 'crimson_archfiend', name: 'Crimson Archfiend', emoji: 'üòà', tier: 6, unlockLevel: 60,
            desc: 'A demon lord wreathed in hellfire, commander of blood legions.',
            rewardType: 'gold', baseHp: 7000, baseDamage: 58, hpPerLevel: 180, dmgPerLevel: 2.8,
            xpReward: 0, goldReward: 10000, regenPerMin: 110,
            lootTable: [
                { name: 'Crimson Ember', emoji: 'üî•', rarity: 'common', str: 6, wis: 3, hp: 30, weight: 50 },
                { name: 'Hellfire Blade', emoji: 'üó°Ô∏è', rarity: 'uncommon', str: 12, wis: 5, hp: 40, weight: 30 },
                { name: 'Archfiend\'s Horn', emoji: 'ü¶¥', rarity: 'rare', str: 20, wis: 12, hp: 70, weight: 15 },
                { name: 'Blood Crown', emoji: '‚ôõ', rarity: 'epic', str: 28, wis: 20, hp: 120, weight: 4 },
                { name: 'Crimson Soulfire', emoji: 'ü©∏', rarity: 'legendary', str: 40, wis: 30, hp: 200, weight: 1 }
            ]
        },
        {
            id: 'phantom_overlord', name: 'Phantom Overlord', emoji: 'üëª', tier: 7, unlockLevel: 70,
            desc: 'The undying specter that rules over all wraiths in the void.',
            rewardType: 'xp', baseHp: 9500, baseDamage: 70, hpPerLevel: 200, dmgPerLevel: 3.0,
            xpReward: 12000, goldReward: 0, regenPerMin: 130,
            lootTable: [
                { name: 'Phantom Thread', emoji: 'üï∏Ô∏è', rarity: 'common', str: 3, wis: 8, hp: 30, weight: 50 },
                { name: 'Spectral Chain', emoji: '‚õìÔ∏è', rarity: 'uncommon', str: 8, wis: 12, hp: 45, weight: 30 },
                { name: 'Overlord\'s Gaze', emoji: 'üëÅÔ∏è', rarity: 'rare', str: 15, wis: 22, hp: 80, weight: 15 },
                { name: 'Wraith King Crown', emoji: 'üëª', rarity: 'epic', str: 25, wis: 30, hp: 140, weight: 4 },
                { name: 'Phantom Dominion', emoji: 'üåå', rarity: 'legendary', str: 35, wis: 45, hp: 220, weight: 1 }
            ]
        },
        {
            id: 'doom_harbinger', name: 'Doom Harbinger', emoji: 'üíÄ', tier: 8, unlockLevel: 80,
            desc: 'The herald of annihilation, whose very presence withers worlds.',
            rewardType: 'gold', baseHp: 12500, baseDamage: 82, hpPerLevel: 230, dmgPerLevel: 3.2,
            xpReward: 0, goldReward: 20000, regenPerMin: 150,
            lootTable: [
                { name: 'Doom Fragment', emoji: '‚ò†Ô∏è', rarity: 'common', str: 8, wis: 5, hp: 35, weight: 50 },
                { name: 'Harbinger\'s Bell', emoji: 'üîî', rarity: 'uncommon', str: 12, wis: 12, hp: 50, weight: 30 },
                { name: 'Apocalypse Rune', emoji: 'üîÆ', rarity: 'rare', str: 22, wis: 18, hp: 90, weight: 15 },
                { name: 'Doomplate Armor', emoji: 'üõ°Ô∏è', rarity: 'epic', str: 30, wis: 25, hp: 160, weight: 4 },
                { name: 'Herald of the End', emoji: '‚ö°', rarity: 'legendary', str: 45, wis: 40, hp: 250, weight: 1 }
            ]
        },
        {
            id: 'void_emperor', name: 'Void Emperor', emoji: 'ü´Ö', tier: 9, unlockLevel: 90,
            desc: 'Supreme ruler of the Void, whose power transcends mortal understanding.',
            rewardType: 'xp', baseHp: 16000, baseDamage: 95, hpPerLevel: 260, dmgPerLevel: 3.5,
            xpReward: 25000, goldReward: 0, regenPerMin: 180,
            lootTable: [
                { name: 'Void Scepter Shard', emoji: 'ü™Ñ', rarity: 'common', str: 8, wis: 8, hp: 40, weight: 50 },
                { name: 'Emperor\'s Sigil', emoji: 'üèÖ', rarity: 'uncommon', str: 14, wis: 14, hp: 55, weight: 30 },
                { name: 'Imperial Voidblade', emoji: '‚öîÔ∏è', rarity: 'rare', str: 25, wis: 20, hp: 100, weight: 15 },
                { name: 'Void Emperor\'s Crown', emoji: 'üëë', rarity: 'epic', str: 35, wis: 35, hp: 180, weight: 4 },
                { name: 'Essence of Void', emoji: 'üåÄ', rarity: 'legendary', str: 50, wis: 50, hp: 300, weight: 1 }
            ]
        },
        {
            id: 'the_primordial', name: 'The Primordial', emoji: 'üï≥Ô∏è', tier: 10, unlockLevel: 100,
            desc: 'The first being. The last being. The Void itself made flesh.',
            rewardType: 'gold', baseHp: 25000, baseDamage: 110, hpPerLevel: 300, dmgPerLevel: 4.0,
            xpReward: 0, goldReward: 50000, regenPerMin: 220,
            lootTable: [
                { name: 'Primordial Dust', emoji: 'üå´Ô∏è', rarity: 'common', str: 10, wis: 10, hp: 50, weight: 50 },
                { name: 'Genesis Fragment', emoji: 'üí†', rarity: 'uncommon', str: 18, wis: 18, hp: 65, weight: 30 },
                { name: 'Primordial Fang', emoji: 'ü¶∑', rarity: 'rare', str: 30, wis: 25, hp: 120, weight: 15 },
                { name: 'The First Flame', emoji: 'üî•', rarity: 'epic', str: 40, wis: 40, hp: 200, weight: 4 },
                { name: 'Primordial Heart', emoji: 'üíó', rarity: 'legendary', str: 60, wis: 60, hp: 400, weight: 1 }
            ]
        }
    ];

    let activeBossFight = null; // { bossId, bossCurrentHp, bossMaxHp }

    // Generate the Void Entity definition based on player's current tier
    function getVoidEntityDef() {
        const tier = (p.voidEntityTier || 0) + 1; // Next tier to fight
        const tierMultiplier = Math.pow(1.20, tier - 1); // 20% scaling per tier
        const rewardMultiplier = Math.pow(1.15, tier - 1); // 15% reward scaling per tier
        const baseReward = Math.floor(5000 * rewardMultiplier);
        return {
            id: 'void_entity',
            name: `Void Entity (Tier ${tier})`,
            emoji: 'üåÄ',
            tier: tier,
            unlockLevel: 100,
            desc: `An infinite manifestation of the Void itself. It reforms stronger each time it falls. Current Tier: ${tier}.`,
            rewardType: 'both',
            baseHp: Math.floor(30000 * tierMultiplier),
            baseDamage: Math.floor(120 * tierMultiplier),
            hpPerLevel: Math.floor(350 * tierMultiplier),
            dmgPerLevel: 4.5 * tierMultiplier,
            xpReward: baseReward,
            goldReward: baseReward,
            regenPerMin: 250,
            lootTable: [] // Void Entity has a fixed Void Essence trophy instead
        };
    }

    // Find a boss definition by ID (supports both static bosses and Void Entity)
    function findBossDef(bossId) {
        if (bossId === 'void_entity') return getVoidEntityDef();
        return BOSS_DEFINITIONS.find(b => b.id === bossId);
    }

    function getBossMaxHp(boss) {
        return boss.baseHp + (p.level * boss.hpPerLevel);
    }

    function getBossDamage(boss) {
        return Math.floor(boss.baseDamage + (p.level * boss.dmgPerLevel));
    }

    function getPlayerBossData() {
        if (!p.bossData) p.bossData = {};
        return p.bossData;
    }

    function refreshBossUI() {
        const list = document.getElementById('boss-list');
        const fightArea = document.getElementById('boss-fight-area');
        const restArea = document.getElementById('boss-rest-area');
        const hpDisplay = document.getElementById('boss-hp-display');
        if (!list) return;

        // Update HP display
        if (hpDisplay && p) {
            hpDisplay.textContent = `HP: ${p.hp} / ${p.maxHp}`;
        }

        // If in active fight, show fight UI, hide rest
        if (activeBossFight) {
            list.classList.add('hidden');
            fightArea.classList.remove('hidden');
            if (restArea) restArea.classList.add('hidden');
            renderBossFight();
            return;
        }

        list.classList.remove('hidden');
        fightArea.classList.add('hidden');
        if (restArea) restArea.classList.remove('hidden');

        const bossData = getPlayerBossData();
        let html = '';

        // Render Void Entity at top if player is level 100+
        if (p.level >= 100) {
            const ve = getVoidEntityDef();
            const veMaxHp = getBossMaxHp(ve);
            const veTier = (p.voidEntityTier || 0) + 1;

            html += `<div class="boss-card void-entity-card">`;
            html += `<div class="boss-tier" style="background:rgba(255,136,0,0.4); color:#ff8800;">‚ö° INFINITE BOSS</div>`;
            html += `<h3 style="margin:0 0 5px 0; color:#ff8800;">${ve.emoji} ${ve.name}</h3>`;
            html += `<p style="color:#888; font-size:0.85rem; margin:5px 0;">${ve.desc}</p>`;

            html += `<div class="boss-hp-bar"><div class="boss-hp-fill" style="width:100%; background:linear-gradient(90deg, #ff8800, #ff0000);"></div>`;
            html += `<div class="boss-hp-text">${veMaxHp.toLocaleString()} / ${veMaxHp.toLocaleString()}</div></div>`;

            html += `<div style="margin:8px 0;">`;
            html += `<span class="boss-reward-tag xp">+${ve.xpReward.toLocaleString()} XP</span>`;
            html += `<span class="boss-reward-tag gold">+${ve.goldReward.toLocaleString()} Gold</span>`;
            html += `<span class="boss-reward-tag item" style="background:rgba(255,136,0,0.15); color:#ff8800; border:1px solid #ff8800;">üåÄ Void Essence</span>`;
            html += `</div>`;

            html += `<div style="font-size:0.8rem; color:#666; margin:5px 0;">Boss Damage: ~${getBossDamage(ve)} per hit</div>`;

            if (p.voidEntityTier > 0) {
                html += `<div style="font-size:0.85rem; color:#ff8800; margin:5px 0;">üåÄ Highest Tier Defeated: <strong>${p.voidEntityTier}</strong></div>`;
            }

            html += `<button class="action-btn" onclick="startBossFight('void_entity')" style="background:#3a1a00; border-color:#884400;">üåÄ Challenge Void Entity</button>`;
            html += `</div>`;

            html += `<div style="border-bottom:2px solid #333; margin:15px 0;"></div>`;
        }

        BOSS_DEFINITIONS.forEach(boss => {
            const unlocked = p.level >= boss.unlockLevel;
            const bd = bossData[boss.id] || {};
            const defeated = bd.defeated || false;
            const maxHp = getBossMaxHp(boss);

            const hpPercent = defeated ? 0 : 100;
            const hpColor = defeated ? '#44ff44' : '#ff4444';

            html += `<div class="boss-card${unlocked ? '' : ' locked'}">`;
            html += `<div class="boss-tier" style="background:${defeated ? 'rgba(0,100,0,0.5); color:#44ff44;' : 'rgba(139,0,0,0.5); color:#ff6666;'}">${defeated ? '‚úì DEFEATED' : unlocked ? 'AVAILABLE' : `üîí LV ${boss.unlockLevel}`}</div>`;
            html += `<h3 style="margin:0 0 5px 0; color:${defeated ? '#44ff44' : 'var(--gold)'};">${boss.emoji} ${boss.name} <span style="color:#666; font-size:0.8rem;">Tier ${boss.tier}</span></h3>`;
            if (boss.image) html += `<div style="margin: 6px 0;"><img src="${boss.image}" alt="${sanitize(boss.name)}" style="max-width:100px; max-height:100px; width:auto; height:auto; image-rendering:pixelated;"></div>`;
            html += `<p style="color:#888; font-size:0.85rem; margin:5px 0;">${boss.desc}</p>`;

            if (unlocked) {
                html += `<div class="boss-hp-bar"><div class="boss-hp-fill" style="width:${hpPercent}%; background:linear-gradient(90deg, ${hpColor}, ${defeated ? '#44ff44' : '#ff0000'});"></div>`;
                html += `<div class="boss-hp-text">${defeated ? 'DEFEATED' : `${maxHp.toLocaleString()} / ${maxHp.toLocaleString()}`}</div></div>`;

                html += `<div style="margin:8px 0;">`;
                if (boss.rewardType === 'xp' || boss.xpReward > 0) html += `<span class="boss-reward-tag xp">+${boss.xpReward.toLocaleString()} XP</span>`;
                if (boss.rewardType === 'gold' || boss.goldReward > 0) html += `<span class="boss-reward-tag gold">+${boss.goldReward.toLocaleString()} Gold</span>`;
                html += `<span class="boss-reward-tag item">+ Trophy Loot</span>`;
                html += `</div>`;

                html += `<div style="font-size:0.8rem; color:#666; margin:5px 0;">Boss Damage: ~${getBossDamage(boss)} per hit</div>`;

                if (!defeated) {
                    html += `<button class="action-btn" onclick="startBossFight('${boss.id}')" style="background:#3a0000; border-color:#660000;">‚öî Challenge Boss</button>`;
                } else {
                    // Show earned trophies for this boss
                    const trophies = (p.trophies || []).filter(t => t.fromBoss === boss.id);
                    if (trophies.length > 0) {
                        html += `<div style="margin-top:8px;"><span style="color:#888; font-size:0.8rem;">Trophies earned:</span><div class="trophy-grid">`;
                        trophies.forEach(t => {
                            html += `<div class="trophy-item rarity-${safeAttr(t.rarity)}" title="+${parseInt(t.str)||0} STR, +${parseInt(t.wis)||0} WIS, +${parseInt(t.hp)||0} HP">${t.emoji} ${sanitize(t.name)}</div>`;
                        });
                        html += `</div></div>`;
                    }
                    html += `<button class="action-btn" onclick="rechallengeBoss('${boss.id}')" style="background:#1a1a2a; border-color:#333;">üîÑ Challenge Again (Farm Loot)</button>`;
                }
            }

            html += `</div>`;
        });

        list.innerHTML = html;
    }

    function startBossFight(bossId) {
        const boss = findBossDef(bossId);
        if (!boss || p.level < boss.unlockLevel) return;

        if (p.hp <= 0) {
            showToast('error', 'Too Weak', 'You must rest before challenging a boss', 'Rest in the Boss Arena first');
            return;
        }

        const maxHp = getBossMaxHp(boss);

        activeBossFight = {
            bossId: bossId,
            bossCurrentHp: maxHp,
            bossMaxHp: maxHp
        };

        refreshBossUI();
    }

    function rechallengeBoss(bossId) {
        const boss = findBossDef(bossId);
        if (!boss) return;

        if (p.hp <= 0) {
            showToast('error', 'Too Weak', 'You must rest before challenging a boss', 'Rest in the Boss Arena first');
            return;
        }

        // Reset boss for rechallenge
        const bossData = getPlayerBossData();
        const maxHp = getBossMaxHp(boss);
        bossData[bossId] = { currentHp: maxHp, lastFightTime: null, defeated: false };

        activeBossFight = {
            bossId: bossId,
            bossCurrentHp: maxHp,
            bossMaxHp: maxHp
        };

        gameAction(() => { markDirty(); });
        refreshBossUI();
    }

    function renderBossFight() {
        const fightArea = document.getElementById('boss-fight-area');
        if (!fightArea || !activeBossFight) return;

        const boss = findBossDef(activeBossFight.bossId);
        if (!boss) return;

        const hpPercent = Math.max(0, (activeBossFight.bossCurrentHp / activeBossFight.bossMaxHp) * 100);
        const isVoidEntity = activeBossFight.bossId === 'void_entity';
        const hpColor = hpPercent > 50 ? (isVoidEntity ? '#ff8800' : '#ff4444') : hpPercent > 25 ? '#ff8800' : '#ffcc00';
        const playerHpPercent = Math.max(0, (p.hp / p.maxHp) * 100);
        const playerHpColor = playerHpPercent > 50 ? '#44ff44' : playerHpPercent > 25 ? '#ffaa00' : '#ff4444';
        const bossDmg = getBossDamage(boss);

        let html = `<div style="border:2px solid var(--accent); padding:20px; background:#0a0a0a;">`;
        html += `<div style="display:flex; justify-content:space-between; align-items:center; flex-wrap:wrap; gap:10px;">`;
        html += `<h3 style="margin:0; color:var(--gold);">${boss.emoji} ${boss.name}</h3>`;
        if (boss.image) html += `<img src="${boss.image}" alt="${sanitize(boss.name)}" style="max-width:80px; max-height:80px; width:auto; height:auto; image-rendering:pixelated;">`;
        html += `<button class="action-btn" onclick="fleeBossFight()" style="background:#333; font-size:0.8rem;">üö™ Flee</button>`;
        html += `</div>`;

        // Boss HP bar
        html += `<div style="margin-top:12px;"><span style="color:#ff6666; font-size:0.8rem;">BOSS HP</span>`;
        html += `<div class="boss-hp-bar"><div class="boss-hp-fill" style="width:${hpPercent}%; background:linear-gradient(90deg, ${hpColor}, #ff0000);"></div>`;
        html += `<div class="boss-hp-text">${activeBossFight.bossCurrentHp.toLocaleString()} / ${activeBossFight.bossMaxHp.toLocaleString()}</div></div></div>`;

        // Player HP bar
        html += `<div style="margin-top:8px;"><span style="color:#44ff44; font-size:0.8rem;">YOUR HP</span>`;
        html += `<div class="boss-hp-bar"><div class="boss-hp-fill" style="width:${playerHpPercent}%; background:linear-gradient(90deg, #1a5a1a, ${playerHpColor});"></div>`;
        html += `<div class="boss-hp-text">${p.hp} / ${p.maxHp}</div></div></div>`;

        // Boss info
        html += `<div style="margin:12px 0; color:#888; font-size:0.85rem;">Boss hits you for ~${bossDmg} per attack ¬∑ Your STR: ${p.str} ¬∑ <span style="color:#ff4444;">No resting mid-fight ¬∑ Fleeing resets the boss</span></div>`;

        if (p.hp <= 0) {
            html += `<div style="padding:15px; text-align:center; color:#ff4444; border:1px solid #ff4444; margin:10px 0;">`;
            html += `<strong>You have fallen!</strong><br>Rest up in the Boss Arena, then try again.`;
            html += `</div>`;
            html += `<button class="action-btn" onclick="fleeBossFight()" style="width:100%;">Return to Boss List</button>`;
        } else {
            html += `<button class="action-btn" onclick="attackBoss()" style="background:#3a0000; border-color:#660000; width:100%; padding:15px; font-size:1rem;">‚öî ATTACK</button>`;
        }

        // Fight log
        html += `<div id="boss-log" style="max-height:150px; overflow-y:auto; margin-top:15px; border-top:1px solid #222; padding-top:10px; font-size:0.85rem; color:#888;"></div>`;

        html += `</div>`;
        fightArea.innerHTML = html;
    }

    function attackBoss() {
        if (rateLimited('bossattack', 400)) return;
        if (!activeBossFight || p.hp <= 0) return;

        const boss = findBossDef(activeBossFight.bossId);
        if (!boss) return;

        playAttackSound();
        gameAction(() => {
            // Player attacks boss
            const playerDamage = Math.floor(p.str * (1.5 + Math.random() * 0.5));
            activeBossFight.bossCurrentHp = Math.max(0, activeBossFight.bossCurrentHp - playerDamage);

            // Boss attacks player (no rest!)
            const bossDmg = getBossDamage(boss);
            const actualBossDmg = Math.floor(bossDmg * (0.8 + Math.random() * 0.4));
            p.hp = Math.max(0, p.hp - actualBossDmg);

            // Save boss state
            const bossData = getPlayerBossData();
            if (!bossData[boss.id]) bossData[boss.id] = {};
            bossData[boss.id].currentHp = activeBossFight.bossCurrentHp;
            bossData[boss.id].lastFightTime = Date.now();

            // Check if boss is dead
            if (activeBossFight.bossCurrentHp <= 0) {
                // Void Entity is never permanently defeated ‚Äî it respawns at next tier
                if (boss.id !== 'void_entity') {
                    bossData[boss.id].defeated = true;
                }
                bossData[boss.id].currentHp = 0;
                bossDefeated(boss);
                return;
            }

            // Check if player is dead
            if (p.hp <= 0) {
                p.hp = 0;
                const goldLost = p.gold;
                p.gold = 0;
                addLog(`<span style="color:#ff4444;">‚ò† You fell fighting ${boss.name}! Lost ${goldLost} gold.</span>`);
            }

            refreshUI();
            markDirty();
        });

        renderBossFight();

        // Add to boss fight log
        const bossLog = document.getElementById('boss-log');
        if (bossLog) {
            bossLog.scrollTop = bossLog.scrollHeight;
        }
    }

    function bossDefeated(boss) {
        const isVoidEntity = boss.id === 'void_entity';
        
        // Roll for loot (not for Void Entity ‚Äî it has a fixed trophy)
        const loot = isVoidEntity ? null : rollBossLoot(boss);

        gameAction(() => {
            const wisMultiplier = 1 + (p.wis / 100);
            
            // Apply rewards ‚Äî XP and gold only granted on kill
            if (boss.xpReward > 0) {
                const finalXp = Math.floor(boss.xpReward * wisMultiplier);
                p.xp += finalXp;
            }
            if (boss.goldReward > 0) p.gold += boss.goldReward;

            if (!p.trophies) p.trophies = [];

            if (isVoidEntity) {
                // Void Entity: increment tier
                if (!p.voidEntityTier) p.voidEntityTier = 0;
                p.voidEntityTier++;
                
                // Update or create the Void Essence trophy (tracks highest tier)
                const existingVoidTrophy = p.trophies.find(t => t.fromBoss === 'void_entity');
                if (existingVoidTrophy) {
                    existingVoidTrophy.name = `Void Essence Tier ${p.voidEntityTier}`;
                    existingVoidTrophy.earnedAt = Date.now();
                } else {
                    p.trophies.push({
                        name: `Void Essence Tier ${p.voidEntityTier}`,
                        emoji: 'üåÄ',
                        rarity: 'legendary',
                        str: 0,
                        wis: 0,
                        hp: 0,
                        fromBoss: 'void_entity',
                        earnedAt: Date.now()
                    });
                }
            } else {
                // Normal boss loot
                p.trophies.push({
                    name: loot.name,
                    emoji: loot.emoji,
                    rarity: loot.rarity,
                    str: loot.str,
                    wis: loot.wis,
                    hp: loot.hp,
                    fromBoss: boss.id,
                    earnedAt: Date.now()
                });

                // Apply permanent stat boosts from trophy
                p.str += loot.str;
                p.wis += loot.wis;
                p.maxHp += loot.hp;
                p.hp = Math.min(p.hp + loot.hp, p.maxHp);
            }

            // Track boss kills for daily quests
            if (!p.totalBossKills) p.totalBossKills = 0;
            p.totalBossKills++;
            trackQuestProgress('bosses', 1);

            // Check level ups
            while (p.xp >= p.level * 100) {
                p.xp -= p.level * 100;
                p.level++;
                p.maxHp += 20;
                p.hp = p.maxHp;
                p.str += 2;
                p.wis += 2;
                addLog(`<span style="color:#4af; font-weight:bold;">LEVEL UP! You are now level ${p.level}. HP fully restored!</span>`);
            }

            refreshUI();
            markDirty(true);
        });

        // Build reward text
        let rewardText = '';
        const wisMultiplier = 1 + (p.wis / 100);
        if (boss.xpReward > 0) rewardText += `+${Math.floor(boss.xpReward * wisMultiplier).toLocaleString()} XP `;
        if (boss.goldReward > 0) rewardText += `+${boss.goldReward.toLocaleString()} Gold `;

        if (isVoidEntity) {
            showToast('victory', `üåÄ Void Entity Tier ${p.voidEntityTier} Defeated!`,
                `${rewardText}`,
                `<span style="color:#ff8800;">üåÄ Void Essence Tier ${p.voidEntityTier} [LEGENDARY]</span><br>The Void Entity grows stronger...`
            );
            addLog(`<span style="color:#ff8800; font-weight:bold;">üåÄ You conquered the Void Entity Tier ${p.voidEntityTier}! It reforms, stronger than before...</span>`);
            sendSystemChat(`üåÄ ${sanitize(p.displayName || currentUser)} has conquered the Void Entity at Tier ${p.voidEntityTier}!`);
        } else {
            const rarityColors = { common:'#aaa', uncommon:'#44ff44', rare:'#4488ff', epic:'#aa44ff', legendary:'#ff8800' };
            const rarityColor = rarityColors[loot.rarity] || '#aaa';

            showToast('victory', `üèÜ ${boss.name} Defeated!`,
                `${rewardText}`,
                `<span style="color:${rarityColor};">${loot.emoji} ${loot.name} [${loot.rarity.toUpperCase()}]</span><br>+${loot.str} STR, +${loot.wis} WIS, +${loot.hp} HP`
            );

            addLog(`<span style="color:var(--gold); font-weight:bold;">üèÜ You defeated ${boss.name}! Earned: ${loot.emoji} ${loot.name} (${loot.rarity})</span>`);
            sendSystemChat(`üèÜ ${sanitize(p.displayName || currentUser)} has slain ${boss.name} and claimed ${loot.emoji} ${sanitize(loot.name)}!`);
        }

        activeBossFight = null;
        refreshBossUI();
    }

    function rollBossLoot(boss) {
        const table = boss.lootTable;
        const totalWeight = table.reduce((sum, item) => sum + item.weight, 0);
        let roll = Math.random() * totalWeight;

        for (const item of table) {
            roll -= item.weight;
            if (roll <= 0) return { ...item };
        }
        return { ...table[0] };
    }

    function fleeBossFight() {
        if (!activeBossFight) return;

        // Reset boss HP on flee
        const boss = findBossDef(activeBossFight.bossId);
        if (boss) {
            const bossData = getPlayerBossData();
            const maxHp = getBossMaxHp(boss);
            if (bossData[boss.id]) {
                bossData[boss.id].currentHp = maxHp;
                bossData[boss.id].lastFightTime = null;
            }
            gameAction(() => { markDirty(); });
            addLog(`<span style="color:#888;">You fled from ${boss.name}. The boss recovers fully.</span>`);
        }

        activeBossFight = null;
        refreshBossUI();
    }

    function resetActiveBoss() {
        if (!activeBossFight) return;

        const boss = findBossDef(activeBossFight.bossId);
        if (boss) {
            const bossData = getPlayerBossData();
            const maxHp = getBossMaxHp(boss);
            if (bossData[boss.id]) {
                bossData[boss.id].currentHp = maxHp;
                bossData[boss.id].lastFightTime = null;
            }
            gameAction(() => { markDirty(); });
        }

        activeBossFight = null;
    }

    function doBossRest() {
        if (activeBossFight) return; // Can't rest during a fight
        gameAction(() => {
            const healAmount = Math.floor(p.maxHp * 0.5);
            const oldHp = p.hp;
            p.hp = Math.min(p.maxHp, p.hp + healAmount);
            const actualHeal = p.hp - oldHp;

            if (actualHeal === 0) {
                addLog(`<span style="color:#888;">You are already at full health.</span>`);
            } else {
                addLog(`<span style="color:#44ff44;">You rest in the Boss Arena. +${actualHeal} HP (${p.hp}/${p.maxHp})</span>`);
                markDirty();
            }
            refreshUI();
        });
        refreshBossUI();
    }

    // Render trophies in player profile/card
    function renderTrophies(trophies) {
        if (!trophies || trophies.length === 0) return '';

        // Stack duplicates by name
        const stacked = {};
        trophies.forEach(t => {
            const key = t.name;
            if (!stacked[key]) {
                stacked[key] = { ...t, count: t.count || 1 };
            } else {
                // For War Hero Trophy, use the tracked count
                if (t.count) {
                    stacked[key].count = t.count;
                } else {
                    stacked[key].count++;
                }
            }
        });

        const rarityOrder = { legendary: 0, epic: 1, rare: 2, uncommon: 3, common: 4 };
        const sorted = Object.values(stacked).sort((a, b) => (rarityOrder[a.rarity] || 5) - (rarityOrder[b.rarity] || 5));

        let html = '<div style="margin-top:15px;"><h4 style="color:var(--gold); margin-bottom:8px;">üèÜ Boss Trophies</h4>';
        html += '<div class="trophy-grid">';

        sorted.forEach(t => {
            const countBadge = t.count > 1 ? ` <span style="font-size:0.75rem; color:#fff; background:rgba(255,255,255,0.15); padding:1px 5px; border-radius:3px;">x${t.count}</span>` : '';
            const safeName = sanitize(t.name);
            const safeRarity = safeAttr(t.rarity);
            html += `<div class="trophy-item rarity-${safeRarity}" style="cursor:pointer;" data-trophy="${safeName}" data-emoji="${t.emoji}" data-rarity="${safeRarity}" data-str="${parseInt(t.str)||0}" data-wis="${parseInt(t.wis)||0}" data-hp="${parseInt(t.hp)||0}" data-count="${parseInt(t.count)||1}" onclick="window._showTrophy(this)">`;
            html += `${t.emoji} ${safeName}${countBadge}`;
            html += `</div>`;
        });

        html += '</div></div>';
        return html;
    }

    function showTrophyDetail(name, emoji, rarity, str, wis, hp, count) {
        const rarityColors = { common:'#aaa', uncommon:'#44ff44', rare:'#4488ff', epic:'#aa44ff', legendary:'#ff8800' };
        const safeRarity = ['common','uncommon','rare','epic','legendary'].includes(rarity) ? rarity : 'common';
        const color = rarityColors[safeRarity] || '#aaa';
        const safeName = sanitize(name);
        const safeStr = parseInt(str) || 0;
        const safeWis = parseInt(wis) || 0;
        const safeHp = parseInt(hp) || 0;
        const safeCount = parseInt(count) || 1;

        // Remove existing popups
        document.querySelectorAll('.trophy-popup').forEach(el => el.remove());

        const popup = document.createElement('div');
        popup.className = 'trophy-popup';
        popup.innerHTML = `
            <div style="font-size:2rem; margin-bottom:8px;">${emoji}</div>
            <div style="color:${color}; font-weight:bold; font-size:1.1rem; text-transform:uppercase; letter-spacing:1px;">${safeName}</div>
            <div style="color:${color}; font-size:0.8rem; margin:4px 0 12px 0;">[${safeRarity.toUpperCase()}]${safeCount > 1 ? ` √ó ${safeCount}` : ''}</div>
            <div style="color:#ccc; font-size:0.9rem; line-height:1.8;">
                <div>+${safeStr} STR <span style="color:#666;">per trophy</span></div>
                <div>+${safeWis} WIS <span style="color:#666;">per trophy</span></div>
                <div>+${safeHp} HP <span style="color:#666;">per trophy</span></div>
            </div>
            ${safeCount > 1 ? `<div style="margin-top:10px; padding-top:10px; border-top:1px solid #333; color:var(--gold); font-size:0.85rem;">Total from ${safeCount}√ó: +${safeStr * safeCount} STR, +${safeWis * safeCount} WIS, +${safeHp * safeCount} HP</div>` : ''}
            <div style="margin-top:12px; font-size:0.75rem; color:#555;">Tap anywhere to close</div>
        `;
        document.body.appendChild(popup);

        // Close on click anywhere
        setTimeout(() => {
            const closer = (e) => {
                if (popup.parentNode) popup.remove();
                document.removeEventListener('click', closer);
            };
            document.addEventListener('click', closer);
        }, 50);
    }
    // ============================================
    // DAILY VOID QUESTS SYSTEM
    // ============================================
    const QUEST_TEMPLATES = [
        // xpPct = fraction of current level's XP-to-next at easiest target
        // goldPct = fraction of (p.level * 5) as base gold at easiest target
        // Difficulty uses sqrt scaling so harder targets don't give absurd linear increases
        { type: 'minions', desc: 'Slay {n} Minions', targets: [20, 40, 60, 80, 100], xpPct: 0.01, goldPct: 0.5 },
        { type: 'bosses', desc: 'Defeat {n} Bosses', targets: [1, 2, 3, 5], xpPct: 0.02, goldPct: 1.0 },
        { type: 'gold', desc: 'Spend {n} Gold', targets: [200, 500, 1000, 2000], xpPct: 0.012, goldPct: 0.6 }
    ];

    function generateDailyQuests() {
        const quests = [];
        const xpToLevel = p.level * 100; // XP needed for next level-up
        // Pick 3 quests ‚Äî one of each type
        const shuffled = [...QUEST_TEMPLATES].sort(() => Math.random() - 0.5);
        for (let i = 0; i < 3; i++) {
            const template = shuffled[i % shuffled.length];
            const target = template.targets[Math.floor(Math.random() * template.targets.length)];
            // sqrt scaling: harder targets give diminishing returns instead of linear blowout
            const difficultyMult = Math.sqrt(target / template.targets[0]);
            const xpReward = Math.max(5, Math.floor(xpToLevel * template.xpPct * difficultyMult));
            const goldReward = Math.max(5, Math.floor(p.level * 5 * template.goldPct * difficultyMult));
            quests.push({
                type: template.type,
                desc: template.desc.replace('{n}', target.toLocaleString()),
                target: target,
                progress: 0,
                goldReward: goldReward,
                xpReward: xpReward,
                claimed: false
            });
        }
        return quests;
    }

    const QUEST_VERSION = 3; // Bump this whenever reward formula changes

    function checkAndResetDailyQuests() {
        if (!p) return;
        const now = Date.now();
        const lastReset = p.dailyQuestsLastReset || 0;
        const TWENTY_FOUR_HOURS = 24 * 60 * 60 * 1000;
        const versionMismatch = (p.dailyQuestsVersion || 0) !== QUEST_VERSION;

        if (!p.dailyQuests || (now - lastReset) >= TWENTY_FOUR_HOURS || versionMismatch) {
            p.dailyQuests = generateDailyQuests();
            p.dailyQuestsLastReset = now;
            p.dailyQuestsVersion = QUEST_VERSION;
            markDirty();
        }
    }

    function trackQuestProgress(type, amount) {
        if (!p || !p.dailyQuests) return;
        p.dailyQuests.forEach(q => {
            if (q.type === type && !q.claimed) {
                q.progress = Math.min(q.target, (q.progress || 0) + amount);
            }
        });
    }

    function claimQuestReward(index) {
        if (!p || !p.dailyQuests || !p.dailyQuests[index]) return;
        const quest = p.dailyQuests[index];
        if (quest.claimed || quest.progress < quest.target) return;

        gameAction(() => {
            const wisMultiplier = 1 + (p.wis / 100);
            const finalXp = Math.floor(quest.xpReward * wisMultiplier);
            p.xp += finalXp;
            p.gold += quest.goldReward;
            quest.claimed = true;

            // Check level ups
            while (p.xp >= p.level * 100) {
                p.xp -= p.level * 100;
                p.level++;
                p.maxHp += 20;
                p.hp = p.maxHp;
                p.str += 2;
                p.wis += 2;
                addLog(`<span style="color:#4af; font-weight:bold;">LEVEL UP! You are now level ${p.level}. HP fully restored!</span>`);
            }

            refreshUI();
            markDirty(true);
        });

        showToast('victory', 'üìú Quest Complete!', quest.desc, `+${quest.goldReward} Gold ¬∑ +${Math.floor(quest.xpReward * (1 + p.wis / 100))} XP`);
        addLog(`<span style="color:var(--gold);">üìú Quest complete: ${quest.desc}. Rewards claimed!</span>`);
        refreshQuestsUI();
    }

    function refreshQuestsUI() {
        checkAndResetDailyQuests();

        const container = document.getElementById('quest-list');
        const timerEl = document.getElementById('quest-timer');
        if (!container) return;

        // Calculate time until next reset
        if (timerEl && p.dailyQuestsLastReset) {
            const nextReset = p.dailyQuestsLastReset + (24 * 60 * 60 * 1000);
            const remaining = Math.max(0, nextReset - Date.now());
            const hours = Math.floor(remaining / (60 * 60 * 1000));
            const mins = Math.floor((remaining % (60 * 60 * 1000)) / (60 * 1000));
            timerEl.innerHTML = `‚è∞ Resets in: <span style="color:var(--gold);">${hours}h ${mins}m</span>`;
        }

        if (!p.dailyQuests || p.dailyQuests.length === 0) {
            container.innerHTML = '<p style="color:#666;">No quests available.</p>';
            return;
        }

        const wisMultiplier = 1 + (p.wis / 100);
        let html = '';

        p.dailyQuests.forEach((quest, i) => {
            const pct = Math.min(100, Math.floor((quest.progress / quest.target) * 100));
            const complete = quest.progress >= quest.target;
            const claimed = quest.claimed;

            html += `<div class="quest-card${claimed ? ' quest-complete' : ''}">`;
            html += `<div style="flex:1;">`;
            html += `<div style="color:${claimed ? '#44ff44' : complete ? '#ff8800' : '#ccc'}; font-weight:bold;">${claimed ? '‚úÖ' : complete ? 'üéâ' : 'üìú'} ${sanitize(quest.desc)}</div>`;
            html += `<div style="display:flex; align-items:center; gap:10px; margin-top:6px;">`;
            html += `<div class="quest-progress-bar"><div class="quest-progress-fill" style="width:${pct}%;${claimed ? 'background:#44ff44;' : ''}"></div></div>`;
            html += `<span style="color:#888; font-size:0.8rem; white-space:nowrap;">${quest.progress.toLocaleString()} / ${quest.target.toLocaleString()}</span>`;
            html += `</div>`;
            html += `<div style="margin-top:4px; font-size:0.8rem; color:#888;">Reward: <span style="color:var(--gold);">${quest.goldReward} Gold</span> + <span style="color:#4af;">${Math.floor(quest.xpReward * wisMultiplier)} XP</span></div>`;
            html += `</div>`;

            if (claimed) {
                html += `<span style="color:#44ff44; font-size:0.85rem; white-space:nowrap;">‚úì Claimed</span>`;
            } else if (complete) {
                html += `<button class="action-btn" onclick="claimQuestReward(${i})" style="background:#2a2a00; border-color:#555500; white-space:nowrap;">Claim Reward</button>`;
            }
            html += `</div>`;
        });

        container.innerHTML = html;
    }

    // ============================================
    // INITIALIZATION
    // ============================================
    window.addEventListener('load', () => {
        updateCloudStatus('Connecting...', '#ffaa00');
        const statusEl = document.getElementById('connection-status');
        if (statusEl) statusEl.textContent = 'Ready ‚Äî local save active';
        goTab('grind');
        
        // Periodic player count update
        setInterval(() => {
            if (currentUser) {
                updatePlayerCount();
                p.lastSeen = Date.now();
            }
        }, 30000);
    });

    // Cleanup on page unload ‚Äî save locally (synchronous & reliable)
    // Cloud sync happens via merge on next login (safer than blind beacon overwrite)
    window.addEventListener('beforeunload', () => {
        if (currentUser && p) {
            p.online = false;
            p.lastSeen = Date.now();
            saveLocalGameState(); // Always save locally (synchronous, never fails)
            
            // Send a MINIMAL beacon with just our player data + a merge hint
            // This is safer than sending full state which overwrites everyone
            if (cloudAvailable) {
                try {
                    const realm = document.getElementById('realm-name')?.value.trim() || 'void-realm-default';
                    const payload = JSON.stringify({
                        realm: realm,
                        accounts: getAccounts(),
                        gameState: {
                            players: gameState.players,
                            guilds: gameState.guilds,
                            wars: gameState.wars,
                            news: gameState.news,
                            gate: gameState.gate,
                            chat: gameState.chat,
                            lastModified: Date.now()
                        },
                        timestamp: Date.now(),
                        beaconSave: true // Flag for potential server-side merge support
                    });
                    // Only send beacon if we haven't synced very recently
                    // (reduces chance of stale-data overwrite on rapid close)
                    if (Date.now() - lastSyncTime > 5000) {
                        navigator.sendBeacon(CLOUD_CONFIG.webAppUrl, payload);
                    }
                } catch (e) {
                    // sendBeacon failed, but localStorage is already saved
                }
            }
        }
        stopCloudSync();
    });

    // Also save when tab becomes hidden (covers phone screen-off, tab switch, etc.)
    document.addEventListener('visibilitychange', () => {
        if (document.visibilityState === 'hidden' && currentUser && p) {
            p.lastSeen = Date.now();
            saveLocalGameState(); // Always save locally first
            // Trigger a proper merge-based cloud save (async, may complete before tab dies)
            if (cloudAvailable && isDirty) {
                saveToCloud();
            }
        }
    });

    // ============================================
    // SECURITY: EXPOSE ONLY NECESSARY FUNCTIONS
    // ============================================
    // These window proxies are the ONLY way to call game functions from HTML onclick.
    // All internal state (p, gameState, _stampIntegrity, etc.) stays private in the IIFE.

    // Auth
    window.switchAuthTab = switchAuthTab;
    window.doLogin = doLogin;
    window.doRegister = doRegister;

    // Navigation
    window.goTab = goTab;
    window.toggleMenu = toggleMenu;
    window.closeMenu = closeMenu;

    // Core game actions (rate-limited internally)
    window.doGrind = doGrind;
    window.doRest = doRest;
    window.sendChatMsg = sendChatMsg;
    window.sendGuildChat = sendGuildChat;
    window.buyItem = buyItem;

    // UI refresh functions
    window.refreshBossUI = refreshBossUI;
    window.refreshQuestsUI = refreshQuestsUI;
    window.refreshPvpTargets = refreshPvpTargets;
    window.refreshGuildUI = refreshGuildUI;
    window.refreshWarsUI = refreshWarsUI;
    window.displayChat = displayChat;
    window.refreshShop = refreshShop;
    window.loadLeaderboard = loadLeaderboard;
    window.refreshNews = refreshNews;
    window.refreshAdminConsole = refreshAdminConsole;
    window.refreshAdminPlayerList = refreshAdminPlayerList;

    // Profile & guild
    window.saveProfile = saveProfile;
    window.selectAvatar = selectAvatar;
    window.showCreateGuild = showCreateGuild;
    window.saveGuildBlurb = saveGuildBlurb;
    window.leaveGuild = leaveGuild;
    window.disbandGuild = disbandGuild;
    window.declareWar = declareWar;
    window.postNews = postNews;

    // Boss system
    window.startBossFight = startBossFight;
    window.rechallengeBoss = rechallengeBoss;
    window.attackBoss = attackBoss;
    window.fleeBossFight = fleeBossFight;
    window.doBossRest = doBossRest;

    // Quest system
    window.claimQuestReward = claimQuestReward;

    // Admin (functions internally verify admin status)
    window.adminResetStats = adminResetStats;
    window.adminFullReset = adminFullReset;
    window.adminClearChat = adminClearChat;
    window.adminClearNews = adminClearNews;
    window.adminClearWars = adminClearWars;
    window.adminGiveGold = adminGiveGold;
    window.downloadBackup = downloadBackup;
    window.uploadBackup = uploadBackup;
    window.dismissDesyncBanner = dismissDesyncBanner;

    // Safe proxy functions for dynamically generated onclick handlers
    // These validate input before calling internal functions
    window._goBack = function() {
        goTab(_lastViewTab || 'grind');
    };
    window._showPlayer = function(name) {
        if (typeof name === 'string' && isValidUsername(name) && gameState.players[name]) {
            showPlayerCard(name);
        }
    };
    window._attackPlayer = function(name) {
        if (typeof name === 'string' && isValidUsername(name) && gameState.players[name]) {
            attackPlayer(name);
        }
    };
    window._joinGuild = function(id) {
        if (typeof id === 'string' && /^guild_\d+$/.test(id)) {
            joinGuild(id);
        }
    };
    window._kickMember = function(name) {
        if (typeof name === 'string' && isValidUsername(name)) {
            kickMember(name);
        }
    };
    window._adminBan = function(name) {
        if (typeof name === 'string' && isValidUsername(name)) {
            adminBanPlayer(name);
        }
    };
    window._adminUnban = function(name) {
        if (typeof name === 'string' && isValidUsername(name)) {
            adminUnbanPlayer(name);
        }
    };
    window._adminDelete = function(name) {
        if (typeof name === 'string' && isValidUsername(name)) {
            adminDeletePlayer(name);
        }
    };
    window._showTrophy = function(el) {
        if (!el || !el.dataset) return;
        const name = el.dataset.trophy || '';
        const emoji = el.dataset.emoji || '';
        const rarity = el.dataset.rarity || 'common';
        const str = parseInt(el.dataset.str) || 0;
        const wis = parseInt(el.dataset.wis) || 0;
        const hp = parseInt(el.dataset.hp) || 0;
        const count = parseInt(el.dataset.count) || 1;
        showTrophyDetail(name, emoji, rarity, str, wis, hp, count);
    };

    // ============================================
    // SECURITY: FREEZE EXPOSED WINDOW FUNCTIONS
    // ============================================
    // Prevent attackers from replacing exposed functions with tampered versions
    const exposedFunctions = [
        'switchAuthTab','doLogin','doRegister','goTab','toggleMenu','closeMenu',
        'doGrind','doRest','sendChatMsg','sendGuildChat','buyItem',
        'refreshBossUI','refreshQuestsUI','refreshPvpTargets','refreshGuildUI',
        'refreshWarsUI','displayChat','refreshShop','loadLeaderboard','refreshNews',
        'refreshAdminConsole','refreshAdminPlayerList','saveProfile','selectAvatar',
        'showCreateGuild','saveGuildBlurb','leaveGuild','disbandGuild','declareWar',
        'postNews','startBossFight','rechallengeBoss','attackBoss','fleeBossFight',
        'doBossRest','claimQuestReward','adminResetStats','adminFullReset',
        'adminClearChat','adminClearNews','adminClearWars','adminGiveGold',
        'downloadBackup','uploadBackup','toggleAudio','dismissDesyncBanner',
        '_goBack','_showPlayer','_attackPlayer','_joinGuild','_kickMember',
        '_adminBan','_adminUnban','_adminDelete','_showTrophy'
    ];
    exposedFunctions.forEach(name => {
        try {
            Object.defineProperty(window, name, {
                value: window[name],
                writable: false,
                configurable: false
            });
        } catch(e) {}
    });

    })(); // END IIFE
</script>
</body>
</html>